{"id":1305,"signature":"class Solution { fun getAllElements(root1: TreeNode?, root2: TreeNode?): List<Int> {","docstring":"Given two binary search trees `root1` and `root2`.\n\nReturn a list containing all the integers from both trees sorted in ascending order.\n\n\nExample 1:\nInput: root1 = [2,1,4], root2 = [1,0,3]\nOutput: [0,1,1,2,3,4]\n\nExample 2:\nInput: root1 = [0,-10,10], root2 = [5,1,7,0,2]\nOutput: [-10,0,0,1,2,5,7,10]\n\nExample 3:\nInput: root1 = [], root2 = [5,1,7,0,2]\nOutput: [0,1,2,5,7]\n\nExample 4:\nInput: root1 = [0,-10,10], root2 = []\nOutput: [-10,0,10]\n\nExample 5:\nInput: root1 = [1,null,8], root2 = [8,1]\nOutput: [1,1,8,8]\n\nConstraints:\nEach tree has at most `5000` nodes.\n\nEach node's value is between `[-10^5, 10^5]`.","body":"class Solution { private val res: MutableList<Int> = mutableListOf() fun getAllElements(root1: TreeNode?, root2: TreeNode?): List<Int> { dfs(root1) dfs(root2) return res.sorted() } private fun dfs(root: TreeNode?) { if (root == null) return if (root?.left != null) dfs(root?.left); if (root?.right != null) dfs(root?.right); res.add(root!!.`val`) } }","difficulty":"medium"}
{"id":872,"signature":"class Solution { fun leafSimilar(root1: TreeNode?, root2: TreeNode?): Boolean {","docstring":"Consider all the leaves of a binary tree, from left to right order, the values of those leaves form a leaf value sequence.\n\nFor example, in the given tree above, the leaf value sequence is `(6, 7, 4, 9, 8)`.\n\nTwo binary trees are considered leaf-similar if their leaf value sequence is the same.\n\nReturn `true` if and only if the two given trees with head nodes `root1` and `root2` are leaf-similar.\n\n\nExample 1:\nInput: root1 = [3,5,1,6,2,9,8,null,null,7,4], root2 = [3,5,1,6,7,4,2,null,null,null,null,null,null,9,8]\nOutput: true\n\nExample 2:\nInput: root1 = [1], root2 = [1]\nOutput: true\n\nExample 3:\nInput: root1 = [1], root2 = [2]\nOutput: false\n\nExample 4:\nInput: root1 = [1,2], root2 = [2,2]\nOutput: true\n\nExample 5:\nInput: root1 = [1,2,3], root2 = [1,3,2]\nOutput: false\n\nConstraints:\nThe number of nodes in each tree will be in the range `[1, 200]`.\n\nBoth of the given trees will have values in the range `[0, 200]`.","body":"import java.util.LinkedList  val list1 = mutableListOf<Int>() val list2 = mutableListOf<Int>() getSequence(root1, list1) getSequence(root2, list2) if (list1.size != list2.size) return false for (i in 0 until list1.size) { if (list1[i] != list2[i]) { return false } } return true } fun getSequence(root: TreeNode?, res: MutableList<Int>) { if (root?.left == null && root?.right == null) res.add(root!!.`val`) if (root?.left != null) getSequence(root?.left, res) if (root?.right != null) getSequence(root?.right, res) } }","difficulty":"easy"}
{"id":26,"signature":"class Solution { fun removeDuplicates(nums: IntArray): Int {","docstring":"Given a sorted array nums, remove the duplicates in-place such that each element appears only once and returns the new length.\n\nDo not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.\n\nClarification:\nConfused why the returned value is an integer but your answer is an array?\nNote that the input array is passed in by reference, which means a modification to the input array will be known to the caller as well.\n\nInternally you can think of this:\n\/\/ nums is passed in by reference. (i.e., without making a copy)\nint len = removeDuplicates(nums);\n\/\/ any modification to nums in your function would be known by the caller.\n\n\/\/ using the length returned by your function, it prints the first len elements.\n\nfor (int i = 0; i < len; i++) {\n    print(nums[i]);\n}\n\nExample 1:\nInput: nums = [1,1,2]\nOutput: 2, nums = [1,2]\nExplanation: Your function should return length = `2`, with the first two elements of `nums` being `1` and `2` respectively. It doesn't matter what you leave beyond the returned length.\n\n\nExample 2:\nInput: nums = [0,0,1,1,1,2,2,3,3,4]\nOutput: 5, nums = [0,1,2,3,4]\nExplanation: Your function should return length = `5`, with the first five elements of `nums` being modified to `0`, `1`, `2`, `3`, and `4` respectively. It doesn't matter what values are set beyond the returned length.\n\n\nConstraints:\n`0 <= nums.length <= 3 * 104`\n`-104 <= nums[i] <= 104`\n`nums` is sorted in ascending order.","body":"var cnt = if (nums.size > 0) 1 else 0 for (i in 1 until nums.size) { if (nums[i] == nums[i-1]) continue nums[cnt] = nums[i] cnt++ } return cnt } }","difficulty":"easy"}
{"id":1583,"signature":"class Solution { fun unhappyFriends(n: Int, preferences: Array<IntArray>, pairs: Array<IntArray>): Int {","docstring":"You are given a list of `preferences` for `n` friends, where `n` is always even.\n\nFor each person `i`, `preferences[i]` contains a list of friends sorted in the order of preference. In other words, a friend earlier in the list is more preferred than a friend later in the list. Friends in each list are denoted by integers from `0` to `n-1`.\n\nAll the friends are divided into pairs. The pairings are given in a list `pairs`, where `pairs[i] = [xi, yi]` denotes `xi` is paired with `yi` and `yi` is paired with `xi`.\n\nHowever, this pairing may cause some of the friends to be unhappy. A friend `x` is unhappy if `x` is paired with `y` and there exists a friend `u` who is paired with `v` but:\n`x` prefers `u` over `y`, and\n`u` prefers `x` over `v`.\n\nReturn the number of unhappy friends.\n\n\nExample 1:\nInput: n = 4, preferences = [[1, 2, 3], [3, 2, 0], [3, 1, 0], [1, 2, 0]], pairs = [[0, 1], [2, 3]]\nOutput: 2\nExplanation:\nFriend 1 is unhappy because:\n- 1 is paired with 0 but prefers 3 over 0, and\n- 3 prefers 1 over 2.\n\nFriend 3 is unhappy because:\n- 3 is paired with 2 but prefers 1 over 2, and\n- 1 prefers 3 over 0.\n\nFriends 0 and 2 are happy.\n\n\nExample 2:\nInput: n = 2, preferences = [[1], [0]], pairs = [[1, 0]]\nOutput: 0\nExplanation: Both friends 0 and 1 are happy.\n\n\nExample 3:\nInput: n = 4, preferences = [[1, 3, 2], [2, 3, 0], [1, 3, 0], [0, 2, 1]], pairs = [[1, 3], [0, 2]]\nOutput: 4\n\nConstraints:\n`2 <= n <= 500`\n`n` is even.\n\n`preferences.length == n`\n`preferences[i].length == n - 1`\n`0 <= preferences[i][j] <= n - 1`\n`preferences[i]` does not contain `i`.\n\nAll values in `preferences[i]` are unique.\n\n`pairs.length == n\/2`\n`pairs[i].length == 2`\n`xi != yi`\n`0 <= xi, yi <= n - 1`\nEach person is contained in exactly one pair.","body":"var matrix = Array(n){ IntArray(n) } for (i in 0 until n) { for (j in 0 until n-1) { matrix[i][preferences[i][j]] = j } } var unhappy = BooleanArray(n) var i = 0 var j = 0 while (i+i < n) { val x = pairs[i][0] val y = pairs[i][1] j = 0 while (j+j < n) { if (i == j) { j++ continue } val u = pairs[j][0] val v = pairs[j][1] if ((matrix[x][u] < matrix[x][y] && matrix[u][x] < matrix[u][v]) || (matrix[x][v] < matrix[x][y] && matrix[v][x] < matrix[v][u])) unhappy[x] = true; if ((matrix[y][u] < matrix[y][x] && matrix[u][y] < matrix[u][v]) || (matrix[y][v] < matrix[y][x] && matrix[v][y] < matrix[v][u])) unhappy[y] = true; j++ } i++ } var ans = 0 for (i in 0 until n) if (unhappy[i]) ans++ return ans } }","difficulty":"medium"}
{"id":114,"signature":"class Solution { fun flatten(root: TreeNode?): Unit {","docstring":"Given the `root` of a binary tree, flatten the tree into a \"linked list\":\nThe \"linked list\" should use the same `TreeNode` class where the `right` child pointer points to the next node in the list and the `left` child pointer is always `null`.\n\nThe \"linked list\" should be in the same order as a pre-order traversal of the binary tree.\n\n\nExample 1:\nInput: root = [1,2,5,3,4,null,6]\nOutput: [1,null,2,null,3,null,4,null,5,null,6]\n\nExample 2:\nInput: root = []\nOutput: []\n\nExample 3:\nInput: root = [0]\nOutput: [0]\n\nConstraints:\nThe number of nodes in the tree is in the range `[0, 2000]`.\n\n`-100 <= Node.val <= 100`\nFollow up: Can you flatten the tree in-place (with `O(1)` extra space)?","body":"var cur = root while (cur != null) { if (cur?.left != null) { var p = cur?.left while (p?.right != null) { p = p?.right } p?.right = cur?.right cur?.right = cur?.left cur?.left = null } cur = cur?.right } } }","difficulty":"medium"}
{"id":3,"signature":"class Solution { fun lengthOfLongestSubstring(s: String): Int {","docstring":"Given a string `s`, find the length of the longest substring without repeating characters.\n\n\nExample 1:\nInput: s = \"abcabcbb\"\nOutput: 3\nExplanation: The answer is \"abc\", with the length of 3.\n\n\nExample 2:\nInput: s = \"bbbbb\"\nOutput: 1\nExplanation: The answer is \"b\", with the length of 1.\n\n\nExample 3:\nInput: s = \"pwwkew\"\nOutput: 3\nExplanation: The answer is \"wke\", with the length of 3.\n\nNotice that the answer must be a substring, \"pwke\" is a subsequence and not a substring.\n\n\nExample 4:\nInput: s = \"\"\nOutput: 0\n\nConstraints:\n`0 <= s.length <= 5 * 104`\n`s` consists of English letters, digits, symbols and spaces.","body":"val mm = HashMap<Char, Int>() var ans = 0 var last = -1 for (i in s.indices) { last = Math.max(last, mm.getOrElse(s[i], {-1})) ans = Math.max(ans, i - last) mm[s[i]] = i } return ans } }","difficulty":"medium"}
{"id":67,"signature":"class Solution { fun addBinary(a: String, b: String): String {","docstring":"Given two binary strings `a` and `b`, return their sum as a binary string.\n\n\nExample 1:\nInput: a = \"11\", b = \"1\"\nOutput: \"100\"\n\nExample 2:\nInput: a = \"1010\", b = \"1011\"\nOutput: \"10101\"\n\nConstraints:\n`1 <= a.length, b.length <= 104`\n`a` and `b` consist only of `'0'` or `'1'` characters.\n\nEach string does not contain leading zeros except for the zero itself.","body":"var lena = a.length-1 var lenb = b.length-1 var res: String = \"\" var cnt = 0 while (lena >= 0 || lenb >= 0) { var temp = 0 if (lena >= 0) temp += a[lena]-'0' lena-- if (lenb >= 0) temp += b[lenb]-'0' lenb-- res += ((temp+cnt)%2).toString() cnt = (temp+cnt)\/2 } if (cnt > 0) res += \"1\" return res.reversed() } }","difficulty":"easy"}
{"id":1038,"signature":"class Solution { fun bstToGst(root: TreeNode?): TreeNode? {","docstring":"Given the `root` of a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus sum of all keys greater than the original key in BST.\n\nAs a reminder, a binary search tree is a tree that satisfies these constraints:\nThe left subtree of a node contains only nodes with keys less than the node's key.\n\nThe right subtree of a node contains only nodes with keys greater than the node's key.\n\nBoth the left and right subtrees must also be binary search trees.\n\nNote: This question is the same as 538: https:\/\/leetcode.com\/problems\/convert-bst-to-greater-tree\/\n\nExample 1:\nInput: root = [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]\nOutput: [30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]\n\nExample 2:\nInput: root = [0,null,1]\nOutput: [1,null,1]\n\nExample 3:\nInput: root = [1,0,2]\nOutput: [3,3,2]\n\nExample 4:\nInput: root = [3,2,4,1]\nOutput: [7,9,4,10]\n\nConstraints:\nThe number of nodes in the tree is in the range `[1, 100]`.\n\n`0 <= Node.val <= 100`\nAll the values in the tree are unique.\n\n`root` is guaranteed to be a valid binary search tree.","body":"class Solution { private var cnt = 0 fun bstToGst(root: TreeNode?): TreeNode? { if (root == null) return null bstToGst(root?.right) val temp = root!!.`val` root!!.`val` += cnt cnt += temp bstToGst(root?.left) return root } }","difficulty":"medium"}
{"id":55,"signature":"class Solution { fun canJump(nums: IntArray): Boolean {","docstring":"Given an array of non-negative integers `nums`, you are initially positioned at the first index of the array.\n\nEach element in the array represents your maximum jump length at that position.\n\nDetermine if you are able to reach the last index.\n\n\nExample 1:\nInput: nums = [2,3,1,1,4]\nOutput: true\nExplanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.\n\n\nExample 2:\nInput: nums = [3,2,1,0,4]\nOutput: false\nExplanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.\n\n\nConstraints:\n`1 <= nums.length <= 3 * 104`\n`0 <= nums[i] <= 105`","body":"val n = nums.size var reach = 0 for (i in 0 until n) { if (i > reach || reach >= n-1) break reach = Math.max(reach, i+nums[i]) } return reach >= n-1 } }","difficulty":"medium"}
{"id":1550,"signature":"class Solution { fun threeConsecutiveOdds(arr: IntArray): Boolean {","docstring":"Given an integer array `arr`, return `true` if there are three consecutive odd numbers in the array. Otherwise, return `false`.\n\n\nExample 1:\nInput: arr = [2,6,4,1]\nOutput: false\nExplanation: There are no three consecutive odds.\n\n\nExample 2:\nInput: arr = [1,2,34,3,4,5,7,23,12]\nOutput: true\nExplanation: [5,7,23] are three consecutive odds.\n\n\nConstraints:\n`1 <= arr.length <= 1000`\n`1 <= arr[i] <= 1000`","body":"val n = arr.size for (i in 0 until arr.size-2) { if (arr[i]%2 == 1 && arr[i+1]%2 == 1 && arr[i+2]%2 == 1) { return true; } } return false; } }","difficulty":"easy"}
{"id":95,"signature":"class Solution { fun generateTrees(n: Int): List<TreeNode?> {","docstring":"Given an integer `n`, return all the structurally unique BST's (binary search trees), which has exactly `n` nodes of unique values from `1` to `n`. Return the answer in any order.\n\n\nExample 1:\nInput: n = 3\nOutput: [[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]\n\nExample 2:\nInput: n = 1\nOutput: [[1]]\n\nConstraints:\n`1 <= n <= 8`","body":"if (n == 0) return mutableListOf<TreeNode?>() return dfs(1, n) } private fun dfs(l: Int, r: Int): List<TreeNode?> { if (l > r) { return mutableListOf<TreeNode?>(null) } var res = mutableListOf<TreeNode?>() for (root in l .. r) { var left = dfs(l, root-1) var right = dfs(root+1, r) for (x in left) for (y in right) { var temp = TreeNode(root) temp.left = x temp.right = y res.add(temp) } } return res } }","difficulty":"medium"}
{"id":64,"signature":"class Solution { fun minPathSum(grid: Array<IntArray>): Int {","docstring":"Given a `m x n` `grid` filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.\n\nNote: You can only move either down or right at any point in time.\n\n\nExample 1:\nInput: grid = [[1,3,1],[1,5,1],[4,2,1]]\nOutput: 7\nExplanation: Because the path 1 \u2192 3 \u2192 1 \u2192 1 \u2192 1 minimizes the sum.\n\n\nExample 2:\nInput: grid = [[1,2,3],[4,5,6]]\nOutput: 12\n\nConstraints:\n`m == grid.length`\n`n == grid[i].length`\n`1 <= m, n <= 200`\n`0 <= grid[i][j] <= 100`","body":"var dp = Array(1005){IntArray(1005, {0})} dp[0][0] = grid[0][0] for (i in 1 until grid.size) dp[i][0] = dp[i-1][0]+grid[i][0] for (i in 1 until grid[0].size) dp[0][i] = dp[0][i-1]+grid[0][i] for (i in 1 until grid.size) { for (j in 1 until grid[0].size) { dp[i][j] = Math.min(dp[i][j-1], dp[i-1][j])+grid[i][j] } } return dp[grid.size-1][grid[0].size-1] } }","difficulty":"medium"}
{"id":38,"signature":"class Solution { fun countAndSay(n: Int): String {","docstring":"The count-and-say sequence is a sequence of digit strings defined by the recursive formula:\n`countAndSay(1) = \"1\"`\n`countAndSay(n)` is the way you would \"say\" the digit string from `countAndSay(n-1)`, which is then converted into a different digit string.\n\nTo determine how you \"say\" a digit string, split it into the minimal number of groups so that each group is a contiguous section all of the same character. Then for each group, say the number of characters, then say the character. To convert the saying into a digit string, replace the counts with a number and concatenate every saying.\n\nFor example, the saying and conversion for digit string `\"3322251\"`:\nGiven a positive integer `n`, return the `nth` term of the count-and-say sequence.\n\n\nExample 1:\nInput: n = 1\nOutput: \"1\"\nExplanation: This is the base case.\n\n\nExample 2:\nInput: n = 4\nOutput: \"1211\"\nExplanation:\ncountAndSay(1) = \"1\"\ncountAndSay(2) = say \"1\" = one 1 = \"11\"\ncountAndSay(3) = say \"11\" = two 1's = \"21\"\ncountAndSay(4) = say \"21\" = one 2 + one 1 = \"12\" + \"11\" = \"1211\"\n\nConstraints:\n`1 <= n <= 30`","body":"var last = \"1\" (1 until n).forEach { var nextStr = \"\" var cnt = 0 for (i in 0 until last.length) { if (i == 0) { cnt++ } else if (last[i] == last[i-1]) { cnt++ } else { nextStr += \"${cnt}${last[i-1]}\" cnt = 1 } if (i == last.length-1) nextStr += \"${cnt}${last[i]}\" } last = nextStr } return last } }","difficulty":"easy"}
{"id":372,"signature":"class Solution { fun superPow(a: Int, b: IntArray): Int {","docstring":"Your task is to calculate `ab` mod `1337` where `a` is a positive integer and `b` is an extremely large positive integer given in the form of an array.\n\n\nExample 1:\nInput: a = 2, b = [3]\nOutput: 8\n\nExample 2:\nInput: a = 2, b = [1,0]\nOutput: 1024\n\nExample 3:\nInput: a = 1, b = [4,3,3,8,5,2]\nOutput: 1\n\nExample 4:\nInput: a = 2147483647, b = [2,0,0]\nOutput: 1198\n\nConstraints:\n`1 <= a <= 231 - 1`\n`1 <= b.length <= 2000`\n`0 <= b[i] <= 9`\n`b` doesn't contain leading zeros.","body":"class Solution { private fun qpow(a: Long, b: Long): Long { var ans = 1L var b = b var a = a%1337 while (b > 0) { if (b%2 == 1L) ans = ans*a a = a*a%1337 b = b.shr(1) } return ans } fun superPow(a: Int, b: IntArray): Int { var ans = 1L var cnt = a.toLong() for (i in b.size-1 downTo 0) { ans = ans * qpow(cnt, b[i].toLong()) % 1337 cnt = qpow(cnt, 10) } return ans.toInt() } }","difficulty":"medium"}
{"id":2,"signature":"class Solution { fun addTwoNumbers(l1: ListNode?, l2: ListNode?): ListNode? {","docstring":"You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\n\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\n\n\nExample 1:\nInput: l1 = [2,4,3], l2 = [5,6,4]\nOutput: [7,0,8]\nExplanation: 342 + 465 = 807.\n\n\nExample 2:\nInput: l1 = [0], l2 = [0]\nOutput: [0]\n\nExample 3:\nInput: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\nOutput: [8,9,9,9,0,0,0,1]\n\nConstraints:\nThe number of nodes in each linked list is in the range `[1, 100]`.\n\n`0 <= Node.val <= 9`\nIt is guaranteed that the list represents a number that does not have leading zeros.","body":"val head = ListNode(0) var p = l1 var q = l2 var cur = head var cnt = 0 while (q != null || p != null) { val x = p?.`val` ?: 0 val y = q?.`val` ?: 0 val temp = x+y+cnt cnt = temp\/10 cur.next = ListNode(temp%10) cur = cur.next if (p != null) p = p?.next if (q != null) q = q?.next } if (cnt > 0) { cur.next = ListNode(cnt) } return head.next } }","difficulty":"easy"}
{"id":1375,"signature":"class Solution { fun numTimesAllBlue(light: IntArray): Int {","docstring":"There is a room with `n` bulbs, numbered from `1` to `n`, arranged in a row from left to right. Initially, all the bulbs are turned off.\n\nAt moment k (for k from `0` to `n - 1`), we turn on the `light[k]` bulb. A bulb change color to blue only if it is on and all the previous bulbs (to the left) are turned on too.\n\nReturn the number of moments in which all turned on bulbs are blue.\n\n\nExample 1:\nInput: light = [2,1,3,5,4]\nOutput: 3\nExplanation: All bulbs turned on, are blue at the moment 1, 2 and 4.\n\n\nExample 2:\nInput: light = [3,2,4,1,5]\nOutput: 2\nExplanation: All bulbs turned on, are blue at the moment 3, and 4 (index-0).\n\n\nExample 3:\nInput: light = [4,1,2,3]\nOutput: 1\nExplanation: All bulbs turned on, are blue at the moment 3 (index-0).\n\nBulb 4th changes to blue at the moment 3.\n\n\nExample 4:\nInput: light = [2,1,4,3,6,5]\nOutput: 3\n\nExample 5:\nInput: light = [1,2,3,4,5,6]\nOutput: 6\n\nConstraints:\n`n == light.length`\n`1 <= n <= 5 * 10^4`\n`light` is a permutation of  `[1, 2, ..., n]`","body":"var sum = 0 var ans = 0 var mm = IntArray(light.size+1) for (i in 1 .. light.size) { sum += i mm[i] = sum } sum = 0 for (i in 0 until light.size) { sum += light[i] if (sum == mm[i+1]) ans++ } return ans } }","difficulty":"medium"}
{"id":210,"signature":"class Solution { fun findOrder(numCourses: Int, prerequisites: Array<IntArray>): IntArray {","docstring":"There are a total of `n` courses you have to take labelled from `0` to `n - 1`.\n\nSome courses may have `prerequisites`, for example, if `prerequisites[i] = [ai, bi]` this means you must take the course `bi` before the course `ai`.\n\nGiven the total number of courses `numCourses` and a list of the `prerequisite` pairs, return the ordering of courses you should take to finish all courses.\n\nIf there are many valid answers, return any of them. If it is impossible to finish all courses, return an empty array.\n\n\nExample 1:\nInput: numCourses = 2, prerequisites = [[1,0]]\nOutput: [0,1]\nExplanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1].\n\n\nExample 2:\nInput: numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]\nOutput: [0,2,1,3]\nExplanation: There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0.\n\nSo one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3].\n\n\nExample 3:\nInput: numCourses = 1, prerequisites = []\nOutput: [0]\n\nConstraints:\n`1 <= numCourses <= 2000`\n`0 <= prerequisites.length <= numCourses * (numCourses - 1)`\n`prerequisites[i].length == 2`\n`0 <= ai, bi < numCourses`\n`ai != bi`\nAll the pairs `[ai, bi]` are distinct.","body":"var q = IntArray(numCourses+1) var edges = Array<MutableList<Int>>(numCourses+1) {mutableListOf<Int>()} var ind = IntArray(numCourses+1) var head = 0 var tail = 0 for (i in prerequisites) { ind[i[0]]++ edges[i[1]].add(i[0]) } var cnt = 0 var ans = IntArray(numCourses) var res = 0 for (i in 0 until numCourses) if (ind[i] == 0) { ans[res++] = i q[tail++] = i cnt++ } while (head < tail) { var top = q[head] for (i in edges[top]) { ind[i]-- if (ind[i] == 0) { ans[res++] = i cnt++ q[tail++] = i } } head++ } if (cnt == numCourses) return ans return intArrayOf() } }","difficulty":"medium"}
{"id":34,"signature":"class Solution { fun searchRange(nums: IntArray, target: Int): IntArray {","docstring":"Given an array of integers `nums` sorted in ascending order, find the starting and ending position of a given `target` value.\n\nIf `target` is not found in the array, return `[-1, -1]`.\n\nFollow up: Could you write an algorithm with `O(log n)` runtime complexity?\n\nExample 1:\nInput: nums = [5,7,7,8,8,10], target = 8\nOutput: [3,4]\n\nExample 2:\nInput: nums = [5,7,7,8,8,10], target = 6\nOutput: [-1,-1]\n\nExample 3:\nInput: nums = [], target = 0\nOutput: [-1,-1]\n\nConstraints:\n`0 <= nums.length <= 105`\n`-109 <= nums[i] <= 109`\n`nums` is a non-decreasing array.\n\n`-109 <= target <= 109`","body":"if (nums.size == 0) return intArrayOf(-1, -1) var l: Int = 0 var r: Int = nums.size-1 var mid = 0 var res = IntArray(2) while (l < r) { mid = (l+r) \/ 2 if (nums[mid] < target) { l = mid+1 } else { r = mid } } if (nums[l] != target) return intArrayOf(-1, -1) res[0] = l r = nums.size-1 while (l < r) { mid = (l+r) \/ 2 + 1 if (nums[mid] == target) { l = mid } else { r = mid-1 } } res[1] = l return res } }","difficulty":"medium"}
{"id":1377,"signature":"class Solution { fun frogPosition(n: Int, edges: Array<IntArray>, t: Int, target: Int): Double {","docstring":"Given an undirected tree consisting of `n` vertices numbered from `1` to `n`. A frog starts jumping from vertex 1. In one second, the frog jumps from its current vertex to another unvisited vertex if they are directly connected. The frog can not jump back to a visited vertex. In case the frog can jump to several vertices, it jumps randomly to one of them with the same probability. Otherwise, when the frog can not jump to any unvisited vertex, it jumps forever on the same vertex.\n\nThe edges of the undirected tree are given in the array `edges`, where `edges[i] = [ai, bi]` means that exists an edge connecting the vertices `ai` and `bi`.\n\nReturn the probability that after `t` seconds the frog is on the vertex `target`.\n\n\nExample 1:\nInput: n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 2, target = 4\nOutput: 0.16666666666666666 \nExplanation: The figure above shows the given graph. The frog starts at vertex 1, jumping with 1\/3 probability to the vertex 2 after second 1 and then jumping with 1\/2 probability to vertex 4 after second 2. Thus the probability for the frog is on the vertex 4 after 2 seconds is 1\/3 * 1\/2 = 1\/6 = 0.16666666666666666. \n\nExample 2:\nInput: n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 1, target = 7\nOutput: 0.3333333333333333\nExplanation: The figure above shows the given graph. The frog starts at vertex 1, jumping with 1\/3 = 0.3333333333333333 probability to the vertex 7 after second 1. \n\nExample 3:\nInput: n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 20, target = 6\nOutput: 0.16666666666666666\n\nConstraints:\n`1 <= n <= 100`\n`edges.length == n - 1`\n`edges[i].length == 2`\n`1 <= ai, bi <= n`\n`1 <= t <= 50`\n`1 <= target <= n`\nAnswers within `10-5` of the actual value will be accepted as correct.","body":"import java.util.LinkedList class Solution { data class Node(val root: Int, val p: Double, val time: Int) fun frogPosition(n: Int, edges: Array<IntArray>, t: Int, target: Int): Double { var q = LinkedList<Node>() var vis = BooleanArray(n+1) var e = Array(n+1, {HashSet<Int>()}) for (edge in edges) { e[edge[0]].add(edge[1]) e[edge[1]].add(edge[0]) } q.push(Node(1, 1.0, 0)) vis[1] = true while (!q.isEmpty()) { var top = q.poll() if (top.time == t && top.root == target) { return top.p } var cnt = 0 for (id in e[top.root]) if (!vis[id]) cnt++ if (top.time < t) { val p = top.p*1.0\/cnt var ok = false for (id in e[top.root]) { if (!vis[id]) { vis[id] = true q.offer(Node(id, p, top.time+1)) ok = true } } if (!ok) q.offer(Node(top.root, top.p, top.time+1)) } } return 0.0 } }","difficulty":"hard"}
{"id":1472,"signature":"class Solution { fun visit(url: String) {","docstring":"You have a browser of one tab where you start on the `homepage` and you can visit another `url`, get back in the history number of `steps` or move forward in the history number of `steps`.\n\nImplement the `BrowserHistory` class:\n`BrowserHistory(string homepage)` Initializes the object with the `homepage` of the browser.\n\n`void visit(string url)` Visits `url` from the current page. It clears up all the forward history.\n\n`string back(int steps)` Move `steps` back in history. If you can only return `x` steps in the history and `steps > x`, you will return only `x` steps. Return the current `url` after moving back in history at most `steps`.\n\n`string forward(int steps)` Move `steps` forward in history. If you can only forward `x` steps in the history and `steps > x`, you will forward only `x` steps. Return the current `url` after forwarding in history at most `steps`.\n\n\nExample:\nInput:\n[\"BrowserHistory\",\"visit\",\"visit\",\"visit\",\"back\",\"back\",\"forward\",\"visit\",\"forward\",\"back\",\"back\"]\n[[\"leetcode.com\"],[\"google.com\"],[\"facebook.com\"],[\"youtube.com\"],[1],[1],[1],[\"linkedin.com\"],[2],[2],[7]]\nOutput:\n[null,null,null,null,\"facebook.com\",\"google.com\",\"facebook.com\",null,\"linkedin.com\",\"google.com\",\"leetcode.com\"]\nExplanation:\nBrowserHistory browserHistory = new BrowserHistory(\"leetcode.com\");\nbrowserHistory.visit(\"google.com\");       \/\/ You are in \"leetcode.com\". Visit \"google.com\"\nbrowserHistory.visit(\"facebook.com\");     \/\/ You are in \"google.com\". Visit \"facebook.com\"\nbrowserHistory.visit(\"youtube.com\");      \/\/ You are in \"facebook.com\". Visit \"youtube.com\"\nbrowserHistory.back(1);                   \/\/ You are in \"youtube.com\", move back to \"facebook.com\" return \"facebook.com\"\nbrowserHistory.back(1);                   \/\/ You are in \"facebook.com\", move back to \"google.com\" return \"google.com\"\nbrowserHistory.forward(1);                \/\/ You are in \"google.com\", move forward to \"facebook.com\" return \"facebook.com\"\nbrowserHistory.visit(\"linkedin.com\");     \/\/ You are in \"facebook.com\". Visit \"linkedin.com\"\nbrowserHistory.forward(2);                \/\/ You are in \"linkedin.com\", you cannot move forward any steps.\n\nbrowserHistory.back(2);                   \/\/ You are in \"linkedin.com\", move back two steps to \"facebook.com\" then to \"google.com\". return \"google.com\"\nbrowserHistory.back(7);                   \/\/ You are in \"google.com\", you can move back only one step to \"leetcode.com\". return \"leetcode.com\"\n\nConstraints:\n`1 <= homepage.length <= 20`\n`1 <= url.length <= 20`\n`1 <= steps <= 100`\n`homepage` and `url` consist of  '.' or lower case English letters.\n\nAt most `5000` calls will be made to `visit`, `back`, and `forward`.","body":"class BrowserHistory(homepage: String) { val st = Array<String>(5005) {\"\"} var cnt = 1 var top = 1 init { st[1] = homepage } fun visit(url: String) { if (cnt == top) { st[++cnt] = url; ++top; } else { st[cnt+1] = url; top = cnt+1; ++cnt; } } fun back(steps: Int): String { if (steps >= cnt) { cnt = 1; return st[cnt]; } else { cnt -= steps; return st[cnt]; } } fun forward(steps: Int): String { if (steps+cnt >= top) { cnt = top; return st[cnt]; } else { cnt += steps; return st[cnt]; } } }","difficulty":"medium"}
{"id":20,"signature":"class Solution { fun isValid(s: String): Boolean {","docstring":"Given a string `s` containing just the characters `'('`, `')'`, `'{'`, `'}'`, `'['` and `']'`, determine if the input string is valid.\n\nAn input string is valid if:\nOpen brackets must be closed by the same type of brackets.\n\nOpen brackets must be closed in the correct order.\n\n\nExample 1:\nInput: s = \"()\"\nOutput: true\n\nExample 2:\nInput: s = \"()[]{}\"\nOutput: true\n\nExample 3:\nInput: s = \"(]\"\nOutput: false\n\nExample 4:\nInput: s = \"([)]\"\nOutput: false\n\nExample 5:\nInput: s = \"{[]}\"\nOutput: true\n\nConstraints:\n`1 <= s.length <= 104`\n`s` consists of parentheses only `'()[]{}'`.","body":"var stk = Stack<Char>() stk.push('#') for (i in s) { if (i == '(') stk.push(i) if (i == '[') stk.push(i) if (i == '{') stk.push(i) if (i == ')') { val c = stk.pop() if (c != '(') return false } if (i == ']') { val c = stk.pop() if (c != '[') return false } if (i == '}') { val c = stk.pop() if (c != '{') return false } } if (stk.size > 1) return false return true } }","difficulty":"easy"}
{"id":1306,"signature":"class Solution { fun canReach(arr: IntArray, start: Int): Boolean {","docstring":"Given an array of non-negative integers `arr`, you are initially positioned at `start` index of the array. When you are at index `i`, you can jump to `i + arr[i]` or `i - arr[i]`, check if you can reach to any index with value 0.\n\nNotice that you can not jump outside of the array at any time.\n\n\nExample 1:\nInput: arr = [4,2,3,0,3,1,2], start = 5\nOutput: true\nExplanation: \nAll possible ways to reach at index 3 with value 0 are: \nindex 5 -> index 4 -> index 1 -> index 3 \nindex 5 -> index 6 -> index 4 -> index 1 -> index 3 \n\nExample 2:\nInput: arr = [4,2,3,0,3,1,2], start = 0\nOutput: true \nExplanation: \nOne possible way to reach at index 3 with value 0 is: \nindex 0 -> index 4 -> index 1 -> index 3\n\nExample 3:\nInput: arr = [3,0,2,1,2], start = 2\nOutput: false\nExplanation: There is no way to reach at index 1 with value 0.\n\n\nConstraints:\n`1 <= arr.length <= 5 * 104`\n`0 <= arr[i] < arr.length`\n`0 <= start < arr.length`","body":"import java.util.LinkedList  val n = arr.size var q = LinkedList<Int>() var vis = BooleanArray(n) q.offer(start) vis[start] = true while (!q.isEmpty()) { val top = q.poll() if (arr[top] == 0) return true if (top+arr[top] < n && !vis[top+arr[top]]) { vis[top+arr[top]] = true q.offer(top+arr[top]) } if (top-arr[top] >= 0 && !vis[top-arr[top]]) { vis[top-arr[top]] = true q.offer(top-arr[top]) } } return false } }","difficulty":"medium"}
{"id":300,"signature":"class Solution { fun lengthOfLIS(nums: IntArray): Int {","docstring":"Given an integer array `nums`, return the length of the longest strictly increasing subsequence.\n\nA subsequence is a sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements. For example, `[3,6,2,7]` is a subsequence of the array `[0,3,1,6,2,2,7]`.\n\n\nExample 1:\nInput: nums = [10,9,2,5,3,7,101,18]\nOutput: 4\nExplanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.\n\n\nExample 2:\nInput: nums = [0,1,0,3,2,3]\nOutput: 4\n\nExample 3:\nInput: nums = [7,7,7,7,7,7,7]\nOutput: 1\n\nConstraints:\n`1 <= nums.length <= 2500`\n`-104 <= nums[i] <= 104`\nFollow up:\nCould you come up with the `O(n2)` solution?\nCould you improve it to `O(n log(n))` time complexity?","body":"var ans = 0 val n = nums.size var dp = IntArray(nums.size+1, {1}) dp[0] = 1 for (i in 1 until n) for (j in 0 until i) if (nums[j] < nums[i]) dp[i] = Math.max(dp[i], dp[j]+1) for (i in 0 until n) { ans = Math.max(ans, dp[i]) } return ans } }","difficulty":"medium"}
{"id":268,"signature":"class Solution { fun missingNumber(nums: IntArray): Int {","docstring":"Given an array `nums` containing `n` distinct numbers in the range `[0, n]`, return the only number in the range that is missing from the array.\n\nFollow up: Could you implement a solution using only `O(1)` extra space complexity and `O(n)` runtime complexity?\n\nExample 1:\nInput: nums = [3,0,1]\nOutput: 2\nExplanation: n = 3 since there are 3 numbers, so all numbers are in the range [0,3]. 2 is the missing number in the range since it does not appear in nums.\n\n\nExample 2:\nInput: nums = [0,1]\nOutput: 2\nExplanation: n = 2 since there are 2 numbers, so all numbers are in the range [0,2]. 2 is the missing number in the range since it does not appear in nums.\n\n\nExample 3:\nInput: nums = [9,6,4,2,3,5,7,0,1]\nOutput: 8\nExplanation: n = 9 since there are 9 numbers, so all numbers are in the range [0,9]. 8 is the missing number in the range since it does not appear in nums.\n\n\nExample 4:\nInput: nums = [0]\nOutput: 1\nExplanation: n = 1 since there is 1 number, so all numbers are in the range [0,1]. 1 is the missing number in the range since it does not appear in nums.\n\n\nConstraints:\n`n == nums.length`\n`1 <= n <= 104`\n`0 <= nums[i] <= n`\nAll the numbers of `nums` are unique.","body":"var sum = 0 var n = nums.size nums.forEach { sum += it } return n*(n+1)\/2 - sum } }","difficulty":"easy"}
{"id":1380,"signature":"class Solution { fun luckyNumbers (matrix: Array<IntArray>): List<Int> {","docstring":"Given a `m * n` matrix of distinct numbers, return all lucky numbers in the matrix in any order.\n\nA lucky number is an element of the matrix such that it is the minimum element in its row and maximum in its column.\n\n\nExample 1:\nInput: matrix = [[3,7,8],[9,11,13],[15,16,17]]\nOutput: [15]\nExplanation: 15 is the only lucky number since it is the minimum in its row and the maximum in its column\n\nExample 2:\nInput: matrix = [[1,10,4,2],[9,3,8,7],[15,16,17,12]]\nOutput: [12]\nExplanation: 12 is the only lucky number since it is the minimum in its row and the maximum in its column.\n\n\nExample 3:\nInput: matrix = [[7,8],[1,2]]\nOutput: [7]\n\nConstraints:\n`m == mat.length`\n`n == mat[i].length`\n`1 <= n, m <= 50`\n`1 <= matrix[i][j] <= 10^5`.\n\nAll elements in the matrix are distinct.","body":"val n = matrix.size val m = matrix[0].size val res = mutableListOf<Int>() for (i in 0 until n) { var temp = 1000000 var pos = 0 for (j in 0 until m) { if (matrix[i][j] < temp) { temp = matrix[i][j] pos = j } } var flag = true for (j in 0 until n) { if (j != i && matrix[j][pos] > temp) { flag = false break } } if (flag) res.add(temp) } return res } }","difficulty":"easy"}
{"id":13,"signature":"class Solution { fun romanToInt(s: String): Int {","docstring":"Roman numerals are represented by seven different symbols: `I`, `V`, `X`, `L`, `C`, `D` and `M`.\n\nSymbol       Value\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000\nFor example, `2` is written as `II` in Roman numeral, just two one's added together. `12` is written as `XII`, which is simply `X + II`. The number `27` is written as `XXVII`, which is `XX + V + II`.\n\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not `IIII`. Instead, the number four is written as `IV`. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as `IX`. There are six instances where subtraction is used:\n`I` can be placed before `V` (5) and `X` (10) to make 4 and 9. \n`X` can be placed before `L` (50) and `C` (100) to make 40 and 90. \n`C` can be placed before `D` (500) and `M` (1000) to make 400 and 900.\n\nGiven a roman numeral, convert it to an integer.\n\n\nExample 1:\nInput: s = \"III\"\nOutput: 3\n\nExample 2:\nInput: s = \"IV\"\nOutput: 4\n\nExample 3:\nInput: s = \"IX\"\nOutput: 9\n\nExample 4:\nInput: s = \"LVIII\"\nOutput: 58\nExplanation: L = 50, V= 5, III = 3.\n\n\nExample 5:\nInput: s = \"MCMXCIV\"\nOutput: 1994\nExplanation: M = 1000, CM = 900, XC = 90 and IV = 4.\n\n\nConstraints:\n`1 <= s.length <= 15`\n`s` contains only the characters `('I', 'V', 'X', 'L', 'C', 'D', 'M')`.\n\nIt is guaranteed that `s` is a valid roman numeral in the range `[1, 3999]`.","body":"class Solution { private val Rm2I = mapOf('I' to 1, 'V' to 5, 'X' to 10, 'L' to 50, 'C' to 100, 'D' to 500, 'M' to 1000) fun romanToInt(s: String): Int { var res = 0 var i = 0 while (i < s.length) { if (i == s.length-1) { res += Rm2I[s[i]]!! break } if (Rm2I[s[i]]!! < Rm2I[s[i+1]]!!) { res += Rm2I[s[i+1]]!!-Rm2I[s[i]]!! i += 2 } else { res += Rm2I[s[i]]!! i++ } } return res } }","difficulty":"easy"}
{"id":1589,"signature":"class Solution { fun maxSumRangeQuery(nums: IntArray, requests: Array<IntArray>): Int {","docstring":"We have an array of integers, `nums`, and an array of `requests` where `requests[i] = [starti, endi]`. The `ith` request asks for the sum of `nums[starti] + nums[starti + 1] + ... + nums[endi - 1] + nums[endi]`. Both `starti` and `endi` are 0-indexed.\n\nReturn the maximum total sum of all requests among all permutations of `nums`.\n\nSince the answer may be too large, return it modulo `109 + 7`.\n\n\nExample 1:\nInput: nums = [1,2,3,4,5], requests = [[1,3],[0,1]]\nOutput: 19\nExplanation: One permutation of nums is [2,1,3,4,5] with the following result: \nrequests[0] -> nums[1] + nums[2] + nums[3] = 1 + 3 + 4 = 8\nrequests[1] -> nums[0] + nums[1] = 2 + 1 = 3\nTotal sum: 8 + 3 = 11.\n\nA permutation with a higher total sum is [3,5,4,2,1] with the following result:\nrequests[0] -> nums[1] + nums[2] + nums[3] = 5 + 4 + 2 = 11\nrequests[1] -> nums[0] + nums[1] = 3 + 5  = 8\nTotal sum: 11 + 8 = 19, which is the best that you can do.\n\n\nExample 2:\nInput: nums = [1,2,3,4,5,6], requests = [[0,1]]\nOutput: 11\nExplanation: A permutation with the max total sum is [6,5,4,3,2,1] with request sums [11].\n\n\nExample 3:\nInput: nums = [1,2,3,4,5,10], requests = [[0,2],[1,3],[1,1]]\nOutput: 47\nExplanation: A permutation with the max total sum is [4,10,5,3,2,1] with request sums [19,18,10].\n\n\nConstraints:\n`n == nums.length`\n`1 <= n <= 105`\n`0 <= nums[i] <= 105`\n`1 <= requests.length <= 105`\n`requests[i].length == 2`\n`0 <= starti <= endi < n`","body":"val n = nums.size val mod = 1000000007L var count = IntArray(n) for (r in requests) { count[r[0]]++ if (r[1]+1 < n) { count[r[1]+1]-- } } for (i in 1 until n) count[i] += count[i-1] nums.sort() count.sort() var res = 0L for (i in 0 until n) res = (res + nums[i].toLong() * count[i]) % mod return res.toInt() } }","difficulty":"medium"}
{"id":23,"signature":"class Solution { fun mergeKLists(lists: Array<ListNode?>): ListNode? {","docstring":"You are given an array of `k` linked-lists `lists`, each linked-list is sorted in ascending order.\n\nMerge all the linked-lists into one sorted linked-list and return it.\n\n\nExample 1:\nInput: lists = [[1,4,5],[1,3,4],[2,6]]\nOutput: [1,1,2,3,4,4,5,6]\nExplanation: The linked-lists are:\n[\n  1->4->5,\n  1->3->4,\n  2->6\n]\nmerging them into one sorted list:\n1->1->2->3->4->4->5->6\n\nExample 2:\nInput: lists = []\nOutput: []\n\nExample 3:\nInput: lists = [[]]\nOutput: []\n\nConstraints:\n`k == lists.length`\n`0 <= k <= 10^4`\n`0 <= lists[i].length <= 500`\n`-10^4 <= lists[i][j] <= 10^4`\n`lists[i]` is sorted in ascending order.\n\nThe sum of `lists[i].length` won't exceed `10^4`.","body":"val queue = PriorityQueue<ListNode>() { a, b -> a.`val`-b.`val` } for (list in lists) { if (list != null) { queue.add(list) } } var head: ListNode? = null var last: ListNode? = null while (queue.isNotEmpty()) { val top = queue.peek() queue.remove() if(top?.next != null) { queue.add(top.next) } if (head == null) { head = top last = top } else { last?.next = top last = top } } return head } }","difficulty":"hard"}
{"id":112,"signature":"class Solution { fun hasPathSum(root: TreeNode?, sum: Int): Boolean {","docstring":"Given the `root` of a binary tree and an integer `targetSum`, return `true` if the tree has a root-to-leaf path such that adding up all the values along the path equals `targetSum`.\n\nA leaf is a node with no children.\n\n\nExample 1:\nInput: root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22\nOutput: true\n\nExample 2:\nInput: root = [1,2,3], targetSum = 5\nOutput: false\n\nExample 3:\nInput: root = [1,2], targetSum = 0\nOutput: false\n\nConstraints:\nThe number of nodes in the tree is in the range `[0, 5000]`.\n\n`-1000 <= Node.val <= 1000`\n`-1000 <= targetSum <= 1000`","body":"class Solution { private var ans: Int = 0 fun hasPathSum(root: TreeNode?, sum: Int): Boolean { if (root == null) return false val cnt = sum-root!!.`val` if (root?.left == null && root?.right == null && cnt == 0) return true return hasPathSum(root?.left, cnt) || hasPathSum(root?.right, cnt) } }","difficulty":"easy"}
{"id":94,"signature":"class Solution { fun inorderTraversal(root: TreeNode?): List<Int> {","docstring":"Given the `root` of a binary tree, return the inorder traversal of its nodes' values.\n\n\nExample 1:\nInput: root = [1,null,2,3]\nOutput: [1,3,2]\n\nExample 2:\nInput: root = []\nOutput: []\n\nExample 3:\nInput: root = [1]\nOutput: [1]\n\nExample 4:\nInput: root = [1,2]\nOutput: [2,1]\n\nExample 5:\nInput: root = [1,null,2]\nOutput: [1,2]\n\nConstraints:\nThe number of nodes in the tree is in the range `[0, 100]`.\n\n`-100 <= Node.val <= 100`\nFollow up:\nRecursive solution is trivial, could you do it iteratively?","body":"class Solution { private val res = mutableListOf<Int>() fun inorderTraversal(root: TreeNode?): List<Int> { if (root == null) return res if (root.left != null) { inorderTraversal(root.left) } res.add(root.`val`) if (root.right != null) { inorderTraversal(root.right) } return res } }","difficulty":"medium"}
{"id":98,"signature":"class Solution { fun isValidBST(root: TreeNode?): Boolean {","docstring":"Given the `root` of a binary tree, determine if it is a valid binary search tree (BST).\n\nA valid BST is defined as follows:\nThe left subtree of a node contains only nodes with keys less than the node's key.\n\nThe right subtree of a node contains only nodes with keys greater than the node's key.\n\nBoth the left and right subtrees must also be binary search trees.\n\n\nExample 1:\nInput: root = [2,1,3]\nOutput: true\n\nExample 2:\nInput: root = [5,1,4,null,null,3,6]\nOutput: false\nExplanation: The root node's value is 5 but its right child's value is 4.\n\n\nConstraints:\nThe number of nodes in the tree is in the range `[1, 104]`.\n\n`-231 <= Node.val <= 231 - 1`","body":"if (root == null) return true return valid(root, Long.MIN_VALUE, Long.MAX_VALUE) } private fun valid(root: TreeNode?, low: Long, high: Long): Boolean { if (root == null) return true if (root!!.`val` <= low || root!!.`val` >= high) return false return valid(root?.left, low, root!!.`val`.toLong()) && valid(root?.right, root!!.`val`.toLong(), high); } }","difficulty":"medium"}
{"id":19,"signature":"class Solution { fun removeNthFromEnd(head: ListNode?, n: Int): ListNode? {","docstring":"Given the `head` of a linked list, remove the `nth` node from the end of the list and return its head.\n\nFollow up: Could you do this in one pass?\n\nExample 1:\nInput: head = [1,2,3,4,5], n = 2\nOutput: [1,2,3,5]\n\nExample 2:\nInput: head = [1], n = 1\nOutput: []\n\nExample 3:\nInput: head = [1,2], n = 1\nOutput: [1]\n\nConstraints:\nThe number of nodes in the list is `sz`.\n\n`1 <= sz <= 30`\n`0 <= Node.val <= 100`\n`1 <= n <= sz`","body":"val temp: ListNode? = ListNode(0).apply { next = head } var fast = temp var slow = temp for (i in 0 .. n) fast = fast?.next while (fast != null) { fast = fast?.next slow = slow?.next } slow?.next = slow?.next?.next return temp?.next } }","difficulty":"medium"}
{"id":198,"signature":"class Solution { fun rob(nums: IntArray): Int {","docstring":"You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.\n\nGiven an integer array `nums` representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.\n\n\nExample 1:\nInput: nums = [1,2,3,1]\nOutput: 4\nExplanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).\n\nTotal amount you can rob = 1 + 3 = 4.\n\n\nExample 2:\nInput: nums = [2,7,9,3,1]\nOutput: 12\nExplanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\n\nTotal amount you can rob = 2 + 9 + 1 = 12.\n\n\nConstraints:\n`1 <= nums.length <= 100`\n`0 <= nums[i] <= 400`","body":"if (nums.size == 0) return 0 if (nums.size == 1) return nums[0] var l = Math.max(nums[0], nums[1]) var ll = nums[0] for (i in 2 until nums.size) { val temp = l l = Math.max(l, ll+nums[i]) ll = temp } return l } }","difficulty":"easy"}
{"id":213,"signature":"class Solution { fun rob(nums: IntArray): Int {","docstring":"You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and it will automatically contact the police if two adjacent houses were broken into on the same night.\n\nGiven an integer array `nums` representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.\n\n\nExample 1:\nInput: nums = [2,3,2]\nOutput: 3\nExplanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses.\n\n\nExample 2:\nInput: nums = [1,2,3,1]\nOutput: 4\nExplanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).\n\nTotal amount you can rob = 1 + 3 = 4.\n\n\nExample 3:\nInput: nums = [0]\nOutput: 0\n\nConstraints:\n`1 <= nums.length <= 100`\n`0 <= nums[i] <= 1000`","body":"if (nums.size == 1) return nums[0] return Math.max(pre_rob(nums.sliceArray(0 until nums.size-1)), pre_rob(nums.sliceArray(1 until nums.size))) } fun pre_rob(nums: IntArray): Int { if (nums.size == 0) return 0 if (nums.size == 1) return nums[0] var l = Math.max(nums[0], nums[1]) var ll = nums[0] for (i in 2 until nums.size) { val temp = l l = Math.max(l, ll+nums[i]) ll = temp } return l } }","difficulty":"medium"}
{"id":62,"signature":"class Solution { fun uniquePaths(m: Int, n: Int): Int {","docstring":"A robot is located at the top-left corner of a `m x n` grid (marked 'Start' in the diagram below).\n\nThe robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).\n\nHow many possible unique paths are there?\n\nExample 1:\nInput: m = 3, n = 7\nOutput: 28\n\nExample 2:\nInput: m = 3, n = 2\nOutput: 3\nExplanation:\nFrom the top-left corner, there are a total of 3 ways to reach the bottom-right corner:\n1. Right -> Down -> Down\n2. Down -> Down -> Right\n3. Down -> Right -> Down\n\nExample 3:\nInput: m = 7, n = 3\nOutput: 28\n\nExample 4:\nInput: m = 3, n = 3\nOutput: 6\n\nConstraints:\n`1 <= m, n <= 100`\nIt's guaranteed that the answer will be less than or equal to `2 * 109`.","body":"var dp = Array(105){IntArray(105, {0})} dp[0][1] = 1 for (i in 1 .. m) { for (j in 1 .. n) { dp[i][j] = dp[i-1][j]+dp[i][j-1] } } return dp[m][n] } }","difficulty":"medium"}
{"id":10,"signature":"class Solution { fun isMatch(s: String, p: String): Boolean {","docstring":"Given an input string (`s`) and a pattern (`p`), implement regular expression matching with support for `'.'` and `'*'` where:` `\n`'.'` Matches any single character.\u200b\u200b\u200b\u200b\n`'*'` Matches zero or more of the preceding element.\n\nThe matching should cover the entire input string (not partial).\n\n\nExample 1:\nInput: s = \"aa\", p = \"a\"\nOutput: false\nExplanation: \"a\" does not match the entire string \"aa\".\n\n\nExample 2:\nInput: s = \"aa\", p = \"a*\"\nOutput: true\nExplanation: '*' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes \"aa\".\n\n\nExample 3:\nInput: s = \"ab\", p = \".*\"\nOutput: true\nExplanation: \".*\" means \"zero or more (*) of any character (.)\".\n\n\nExample 4:\nInput: s = \"aab\", p = \"c*a*b\"\nOutput: true\nExplanation: c can be repeated 0 times, a can be repeated 1 time. Therefore, it matches \"aab\".\n\n\nExample 5:\nInput: s = \"mississippi\", p = \"mis*is*p*.\"\nOutput: false\n\nConstraints:\n`0 <= s.length <= 20`\n`0 <= p.length <= 30`\n`s` contains only lowercase English letters.\n\n`p` contains only lowercase English letters, `'.'`, and `'*'`.\n\nIt is guaranteed for each appearance of the character `'*'`, there will be a previous valid character to match.","body":"var dp = Array(s.length+1){BooleanArray(p.length+1, {false})} dp[0][0] = true for (i in 0 .. s.length) { for (j in 1 .. p.length) { if (i > 0 && (s[i-1] == p[j-1] || p[j-1] == '.')) { dp[i][j] = dp[i-1][j-1] } if (p[j-1] == '*') { if (i == 0 || (s[i-1] != p[j-2] && p[j-2] != '.')) { dp[i][j] = dp[i][j-2] } else { dp[i][j] = dp[i-1][j] || dp[i][j-1] || dp[i][j-2] } } } } return dp[s.length][p.length] } }","difficulty":"hard"}
{"id":999,"signature":"class Solution { fun numRookCaptures(board: Array<CharArray>): Int {","docstring":"On an `8 x 8` chessboard, there is exactly one white rook `'R'` and some number of white bishops `'B'`, black pawns `'p'`, and empty squares `'.'`.\n\nWhen the rook moves, it chooses one of four cardinal directions (north, east, south, or west), then moves in that direction until it chooses to stop, reaches the edge of the board, captures a black pawn, or is blocked by a white bishop. A rook is considered attacking a pawn if the rook can capture the pawn on the rook's turn. The number of available captures for the white rook is the number of pawns that the rook is attacking.\n\nReturn the number of available captures for the white rook.\n\n\nExample 1:\nInput: board = [[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"R\",\".\",\".\",\".\",\"p\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\nOutput: 3\nExplanation: In this example, the rook is attacking all the pawns.\n\n\nExample 2:\nInput: board = [[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\"p\",\"p\",\"p\",\"p\",\"p\",\".\",\".\"],[\".\",\"p\",\"p\",\"B\",\"p\",\"p\",\".\",\".\"],[\".\",\"p\",\"B\",\"R\",\"B\",\"p\",\".\",\".\"],[\".\",\"p\",\"p\",\"B\",\"p\",\"p\",\".\",\".\"],[\".\",\"p\",\"p\",\"p\",\"p\",\"p\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\nOutput: 0\nExplanation: The bishops are blocking the rook from attacking any of the pawns.\n\n\nExample 3:\nInput: board = [[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\"p\",\"p\",\".\",\"R\",\".\",\"p\",\"B\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"B\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\nOutput: 3\nExplanation: The rook is attacking the pawns at positions b5, d6, and f5.\n\n\nConstraints:\n`board.length == 8`\n`board[i].length == 8`\n`board[i][j]` is either `'R'`, `'.'`, `'B'`, or `'p'`\nThere is exactly one cell with `board[i][j] == 'R'`","body":"var ans = 0 var (sx, sy) = Pair(0, 0) loop@ for (i in 0 until 8) { for (j in 0 until 8 ) { if (board[i][j] == 'R') { sx = i sy = j break@loop } } } var (tx, ty) = Pair(sx, sy) while (true) { if (board[tx][ty] == 'p') { ans++ break } if (board[tx][ty] == 'B') break tx-- if (tx < 0) break } tx = sx ty = sy while (true) { if (board[tx][ty] == 'p') { ans++ break } if (board[tx][ty] == 'B') break ty++ if (ty >= 8) break } tx = sx ty = sy while (true) { if (board[tx][ty] == 'p') { ans++ break } if (board[tx][ty] == 'B') break tx++ if (tx >= 8) break } tx = sx ty = sy while (true) { if (board[tx][ty] == 'p') { ans++ break } if (board[tx][ty] == 'B') break ty-- if (ty < 0) break } return ans } }","difficulty":"easy"}
{"id":63,"signature":"class Solution { fun uniquePathsWithObstacles(obstacleGrid: Array<IntArray>): Int {","docstring":"A robot is located at the top-left corner of a `m x n` grid (marked 'Start' in the diagram below).\n\nThe robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).\n\nNow consider if some obstacles are added to the grids. How many unique paths would there be?\nAn obstacle and space is marked as `1` and `0` respectively in the grid.\n\n\nExample 1:\nInput: obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]\nOutput: 2\nExplanation: There is one obstacle in the middle of the 3x3 grid above.\n\nThere are two ways to reach the bottom-right corner:\n1. Right -> Right -> Down -> Down\n2. Down -> Down -> Right -> Right\n\nExample 2:\nInput: obstacleGrid = [[0,1],[0,0]]\nOutput: 1\n\nConstraints:\n`m == obstacleGrid.length`\n`n == obstacleGrid[i].length`\n`1 <= m, n <= 100`\n`obstacleGrid[i][j]` is `0` or `1`.","body":"var dp = Array(105){IntArray(105, {0})} dp[0][0] = if (obstacleGrid[0][0] == 1) 0 else 1 for (i in 1 until obstacleGrid.size) if (obstacleGrid[i][0] != 1) dp[i][0] = dp[i-1][0] for (i in 1 until obstacleGrid[0].size) if (obstacleGrid[0][i] != 1) dp[0][i] = dp[0][i-1] for (i in 1 until obstacleGrid.size) { for (j in 1 until obstacleGrid[0].size) { if (obstacleGrid[i][j] == 1) dp[i][j] = 0 else dp[i][j] = dp[i-1][j] + dp[i][j-1] } } return dp[obstacleGrid.size-1][obstacleGrid[0].size-1] } }","difficulty":"medium"}
{"id":1582,"signature":"class Solution { fun numSpecial(mat: Array<IntArray>): Int {","docstring":"Given a `rows x cols` matrix `mat`, where `mat[i][j]` is either `0` or `1`, return the number of special positions in `mat`.\n\nA position `(i,j)` is called special if `mat[i][j] == 1` and all other elements in row `i` and column `j` are `0` (rows and columns are 0-indexed).\n\n\nExample 1:\nInput: mat = [[1,0,0],\n              [0,0,1],\n              [1,0,0]]\nOutput: 1\nExplanation: (1,2) is a special position because mat[1][2] == 1 and all other elements in row 1 and column 2 are 0.\n\n\nExample 2:\nInput: mat = [[1,0,0],\n              [0,1,0],\n              [0,0,1]]\nOutput: 3\nExplanation: (0,0), (1,1) and (2,2) are special positions. \n\nExample 3:\nInput: mat = [[0,0,0,1],\n              [1,0,0,0],\n              [0,1,1,0],\n              [0,0,0,0]]\nOutput: 2\n\nExample 4:\nInput: mat = [[0,0,0,0,0],\n              [1,0,0,0,0],\n              [0,1,0,0,0],\n              [0,0,1,0,0],\n              [0,0,0,1,1]]\nOutput: 3\n\nConstraints:\n`rows == mat.length`\n`cols == mat[i].length`\n`1 <= rows, cols <= 100`\n`mat[i][j]` is `0` or `1`.","body":"var res = 0 for (i in 0 until mat.size) { var cnt = 0 for (j in 0 until mat[0].size) { if (mat[i][j] == 1) { cnt++ if (cnt > 1) break var ok = true for (k in 0 until mat.size) { if (i != k && mat[k][j] != 0) { ok = false break } } for (k in 0 until mat[0].size) { if (j != k && mat[i][k] != 0) { ok = false break } } res = res + if (ok) 1 else 0 } } } return res } }","difficulty":"easy"}
{"id":11,"signature":"class Solution { fun maxArea(height: IntArray): Int {","docstring":"Given `n` non-negative integers `a1, a2, ..., an` , where each represents a point at coordinate `(i, ai)`. `n` vertical lines are drawn such that the two endpoints of the line `i` is at `(i, ai)` and `(i, 0)`. Find two lines, which, together with the x-axis forms a container, such that the container contains the most water.\n\nNotice that you may not slant the container.\n\n\nExample 1:\nInput: height = [1,8,6,2,5,4,8,3,7]\nOutput: 49\nExplanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.\n\n\nExample 2:\nInput: height = [1,1]\nOutput: 1\n\nExample 3:\nInput: height = [4,3,2,1,4]\nOutput: 16\n\nExample 4:\nInput: height = [1,2,1]\nOutput: 2\n\nConstraints:\n`n == height.length`\n`2 <= n <= 105`\n`0 <= height[i] <= 104`","body":"var left = 0 var right = height.size-1 var maxa = 0 while (left < right) { maxa = Math.max(maxa, Math.min(height[left], height[right])*(right-left)) if (height[left] > height[right]) { right-- } else { left++ } } return maxa } }","difficulty":"medium"}
{"id":44,"signature":"class Solution { fun isMatch(s: String, p: String): Boolean {","docstring":"Given an input string (`s`) and a pattern (`p`), implement wildcard pattern matching with support for `'?'` and `'*'` where:\n`'?'` Matches any single character.\n\n`'*'` Matches any sequence of characters (including the empty sequence).\n\nThe matching should cover the entire input string (not partial).\n\n\nExample 1:\nInput: s = \"aa\", p = \"a\"\nOutput: false\nExplanation: \"a\" does not match the entire string \"aa\".\n\n\nExample 2:\nInput: s = \"aa\", p = \"*\"\nOutput: true\nExplanation: '*' matches any sequence.\n\n\nExample 3:\nInput: s = \"cb\", p = \"?a\"\nOutput: false\nExplanation: '?' matches 'c', but the second letter is 'a', which does not match 'b'.\n\n\nExample 4:\nInput: s = \"adceb\", p = \"*a*b\"\nOutput: true\nExplanation: The first '*' matches the empty sequence, while the second '*' matches the substring \"dce\".\n\n\nExample 5:\nInput: s = \"acdcb\", p = \"a*c?b\"\nOutput: false\n\nConstraints:\n`0 <= s.length, p.length <= 2000`\n`s` contains only lowercase English letters.\n\n`p` contains only lowercase English letters, `'?'` or `'*'`.","body":"var dp = Array(s.length+1){BooleanArray(p.length+1, {false})} dp[0][0] = true for (i in 0 .. s.length) { for (j in 1 .. p.length) { if (p[j-1] == '*') { dp[i][j] = dp[i][j-1] || (i > 0 && dp[i-1][j]) } else { dp[i][j] = i > 0 && dp[i-1][j-1] && (s[i-1] == p[j-1] || p[j-1] == '?') } } } return dp[s.length][p.length] } }","difficulty":"hard"}
{"id":1376,"signature":"class Solution { fun numOfMinutes(n: Int, headID: Int, manager: IntArray, informTime: IntArray): Int {","docstring":"A company has `n` employees with a unique ID for each employee from `0` to `n - 1`. The head of the company is the one with `headID`.\n\nEach employee has one direct manager given in the `manager` array where `manager[i]` is the direct manager of the `i-th` employee, `manager[headID] = -1`. Also, it is guaranteed that the subordination relationships have a tree structure.\n\nThe head of the company wants to inform all the company employees of an urgent piece of news. He will inform his direct subordinates, and they will inform their subordinates, and so on until all employees know about the urgent news.\n\nThe `i-th` employee needs `informTime[i]` minutes to inform all of his direct subordinates (i.e., After informTime[i] minutes, all his direct subordinates can start spreading the news).\n\nReturn the number of minutes needed to inform all the employees about the urgent news.\n\n\nExample 1:\nInput: n = 1, headID = 0, manager = [-1], informTime = [0]\nOutput: 0\nExplanation: The head of the company is the only employee in the company.\n\n\nExample 2:\nInput: n = 6, headID = 2, manager = [2,2,-1,2,2,2], informTime = [0,0,1,0,0,0]\nOutput: 1\nExplanation: The head of the company with id = 2 is the direct manager of all the employees in the company and needs 1 minute to inform them all.\n\nThe tree structure of the employees in the company is shown.\n\n\nExample 3:\nInput: n = 7, headID = 6, manager = [1,2,3,4,5,6,-1], informTime = [0,6,5,4,3,2,1]\nOutput: 21\nExplanation: The head has id = 6. He will inform employee with id = 5 in 1 minute.\n\nThe employee with id = 5 will inform the employee with id = 4 in 2 minutes.\n\nThe employee with id = 4 will inform the employee with id = 3 in 3 minutes.\n\nThe employee with id = 3 will inform the employee with id = 2 in 4 minutes.\n\nThe employee with id = 2 will inform the employee with id = 1 in 5 minutes.\n\nThe employee with id = 1 will inform the employee with id = 0 in 6 minutes.\n\nNeeded time = 1 + 2 + 3 + 4 + 5 + 6 = 21.\n\n\nExample 4:\nInput: n = 15, headID = 0, manager = [-1,0,0,1,1,2,2,3,3,4,4,5,5,6,6], informTime = [1,1,1,1,1,1,1,0,0,0,0,0,0,0,0]\nOutput: 3\nExplanation: The first minute the head will inform employees 1 and 2.\n\nThe second minute they will inform employees 3, 4, 5 and 6.\n\nThe third minute they will inform the rest of employees.\n\n\nExample 5:\nInput: n = 4, headID = 2, manager = [3,3,-1,2], informTime = [0,0,162,914]\nOutput: 1076\n\nConstraints:\n`1 <= n <= 105`\n`0 <= headID < n`\n`manager.length == n`\n`0 <= manager[i] < n`\n`manager[headID] == -1`\n`informTime.length == n`\n`0 <= informTime[i] <= 1000`\n`informTime[i] == 0` if employee `i` has no subordinates.\n\nIt is guaranteed that all the employees can be informed.","body":"var mm = Array(n, {HashSet<Int>()}) var dp = IntArray(n) for (i in 0 until n) if (i != headID) mm[manager[i]].add(i) fun DP(i: Int): Int { if (dp[i] > 0) return dp[i] for (j in mm[i]) { dp[i] = Math.max(dp[i], DP(j) + informTime[i]) } return dp[i] } return DP(headID) } }","difficulty":"medium"}
{"id":1362,"signature":"class Solution { fun closestDivisors(num: Int): IntArray {","docstring":"Given an integer `num`, find the closest two integers in absolute difference whose product equals `num + 1` or `num + 2`.\n\nReturn the two integers in any order.\n\n\nExample 1:\nInput: num = 8\nOutput: [3,3]\nExplanation: For num + 1 = 9, the closest divisors are 3 & 3, for num + 2 = 10, the closest divisors are 2 & 5, hence 3 & 3 is chosen.\n\n\nExample 2:\nInput: num = 123\nOutput: [5,25]\n\nExample 3:\nInput: num = 999\nOutput: [40,25]\n\nConstraints:\n`1 <= num <= 10^9`","body":"val len = Math.sqrt((num+2).toDouble()).toInt() for (i in len downTo 1) { if ((num+1)%i == 0) return intArrayOf(i, (num+1)\/i) if ((num+2)%i == 0) return intArrayOf(i, (num+2)\/i) } return intArrayOf(0, 0) } }","difficulty":"medium"}
{"id":1370,"signature":"class Solution { fun sortString(s: String): String {","docstring":"Given a string `s`. You should re-order the string using the following algorithm:\nPick the smallest character from `s` and append it to the result.\n\nPick the smallest character from `s` which is greater than the last appended character to the result and append it.\n\nRepeat step 2 until you cannot pick more characters.\n\nPick the largest character from `s` and append it to the result.\n\nPick the largest character from `s` which is smaller than the last appended character to the result and append it.\n\nRepeat step 5 until you cannot pick more characters.\n\nRepeat the steps from 1 to 6 until you pick all characters from `s`.\n\nIn each step, If the smallest or the largest character appears more than once you can choose any occurrence and append it to the result.\n\nReturn the result string after sorting `s` with this algorithm.\n\n\nExample 1:\nInput: s = \"aaaabbbbcccc\"\nOutput: \"abccbaabccba\"\nExplanation: After steps 1, 2 and 3 of the first iteration, result = \"abc\"\nAfter steps 4, 5 and 6 of the first iteration, result = \"abccba\"\nFirst iteration is done. Now s = \"aabbcc\" and we go back to step 1\nAfter steps 1, 2 and 3 of the second iteration, result = \"abccbaabc\"\nAfter steps 4, 5 and 6 of the second iteration, result = \"abccbaabccba\"\n\nExample 2:\nInput: s = \"rat\"\nOutput: \"art\"\nExplanation: The word \"rat\" becomes \"art\" after re-ordering it with the mentioned algorithm.\n\n\nExample 3:\nInput: s = \"leetcode\"\nOutput: \"cdelotee\"\n\nExample 4:\nInput: s = \"ggggggg\"\nOutput: \"ggggggg\"\n\nExample 5:\nInput: s = \"spo\"\nOutput: \"ops\"\n\nConstraints:\n`1 <= s.length <= 500`\n`s` contains only lower-case English letters.","body":"var ans = StringBuilder() var cnt = IntArray(26) for (c in s) cnt[c-'a']++ while (ans.length < s.length) { add(cnt, ans, true) add(cnt, ans, false) } return ans.toString() } private fun add(cnt: IntArray, ans: StringBuilder, asc:Boolean) { for (i in 0 until 26) { val j = if (asc) i else 25-i if (cnt[j]-- > 0) ans.append((j+'a'.toInt()).toChar()) } } }","difficulty":"easy"}
{"id":402,"signature":"class Solution { fun removeKdigits(num: String, k: Int): String {","docstring":"Given a non-negative integer num represented as a string, remove k digits from the number so that the new number is the smallest possible.\n\nNote:\nThe length of num is less than 10002 and will be \u2265 k.\n\nThe given num does not contain any leading zero.\n\n\nExample 1:\nInput: num = \"1432219\", k = 3\nOutput: \"1219\"\nExplanation: Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest.\n\n\nExample 2:\nInput: num = \"10200\", k = 1\nOutput: \"200\"\nExplanation: Remove the leading 1 and the number is 200. Note that the output must not contain leading zeroes.\n\n\nExample 3:\nInput: num = \"10\", k = 2\nOutput: \"0\"\nExplanation: Remove all the digits from the number and it is left with nothing which is 0.","body":"var newL = num.length - k var s = k var stk = CharArray(num.length) var top = 0 for (i in num) { while (s > 0 && top > 0 && stk[top-1] > i) { top-- s-- } stk[top++] = i } var offset = 0 while (offset < newL && stk[offset] == '0') { offset++ } return if (offset == newL) \"0\" else String(stk, offset, newL-offset) } }","difficulty":"medium"}
{"id":134,"signature":"class Solution { fun canCompleteCircuit(gas: IntArray, cost: IntArray): Int {","docstring":"There are `n` gas stations along a circular route, where the amount of gas at the `ith` station is `gas[i]`.\n\nYou have a car with an unlimited gas tank and it costs `cost[i]` of gas to travel from the `ith` station to its next `(i + 1)th` station. You begin the journey with an empty tank at one of the gas stations.\n\nGiven two integer arrays `gas` and `cost`, return the starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return `-1`. If there exists a solution, it is guaranteed to be unique\n\nExample 1:\nInput: gas = [1,2,3,4,5], cost = [3,4,5,1,2]\nOutput: 3\nExplanation:\nStart at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4\nTravel to station 4. Your tank = 4 - 1 + 5 = 8\nTravel to station 0. Your tank = 8 - 2 + 1 = 7\nTravel to station 1. Your tank = 7 - 3 + 2 = 6\nTravel to station 2. Your tank = 6 - 4 + 3 = 5\nTravel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.\n\nTherefore, return 3 as the starting index.\n\n\nExample 2:\nInput: gas = [2,3,4], cost = [3,4,3]\nOutput: -1\nExplanation:\nYou can't start at station 0 or 1, as there is not enough gas to travel to the next station.\n\nLet's start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4\nTravel to station 0. Your tank = 4 - 3 + 2 = 3\nTravel to station 1. Your tank = 3 - 3 + 3 = 3\nYou cannot travel back to station 2, as it requires 4 unit of gas but you only have 3.\n\nTherefore, you can't travel around the circuit once no matter where you start.\n\n\nConstraints:\n`gas.length == n`\n`cost.length == n`\n`1 <= n <= 104`\n`0 <= gas[i], cost[i] <= 104`","body":"val n = gas.size var sum = 0 for (i in 0 until n) { sum += gas[i]-cost[i] } if (sum < 0) return -1 var start = 0 var restGas = 0 for (i in 0 until n) { var temp = gas[i]-cost[i] if (restGas+temp < 0) { start = i+1 restGas = 0 } else { restGas += temp } } return start } }","difficulty":"medium"}
{"id":16,"signature":"class Solution { fun threeSumClosest(nums: IntArray, target: Int): Int {","docstring":"Given an array `nums` of n integers and an integer `target`, find three integers in `nums` such that the sum is closest to `target`. Return the sum of the three integers. You may assume that each input would have exactly one solution.\n\n\nExample 1:\nInput: nums = [-1,2,1,-4], target = 1\nOutput: 2\nExplanation: The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).\n\n\nConstraints:\n`3 <= nums.length <= 10^3`\n`-10^3 <= nums[i] <= 10^3`\n`-10^4 <= target <= 10^4`","body":"nums.sort() var mina = Int.MAX_VALUE var closedSum = 0 for (i in 0 until nums.size-2) { var left = i+1 var right = nums.size-1 while (left < right) { var sum = nums[i]+nums[left]+nums[right] var diff = Math.abs(sum-target) if (diff < mina) { closedSum = sum mina = diff } if (sum < target) { left++ } else if (sum > target) { right-- } else { return sum } } } return closedSum } }","difficulty":"medium"}
{"id":9,"signature":"class Solution { fun isPalindrome(x: Int): Boolean {","docstring":"Given an integer `x`, return `true` if `x` is palindrome integer.\n\nAn integer is a palindrome when it reads the same backward as forward. For example, `121` is palindrome while `123` is not.\n\n\nExample 1:\nInput: x = 121\nOutput: true\n\nExample 2:\nInput: x = -121\nOutput: false\nExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.\n\n\nExample 3:\nInput: x = 10\nOutput: false\nExplanation: Reads 01 from right to left. Therefore it is not a palindrome.\n\n\nExample 4:\nInput: x = -101\nOutput: false\n\nConstraints:\n`-231 <= x <= 231 - 1`\nFollow up: Could you solve it without converting the integer to a string?","body":"if (x < 0) return false var a = IntArray(20) var cnt = 0 var n = x while (n > 0) { a[cnt++] = n%10 n \/= 10 } for (i in 0 until cnt\/2) { if (a[i] != a[cnt-i-1]) return false } return true } }","difficulty":"easy"}
{"id":6,"signature":"class Solution { fun convert(s: String, numRows: Int): String {","docstring":"The string `\"PAYPALISHIRING\"` is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)\nP   A   H   N\nA P L S I I G\nY   I   R\nAnd then read line by line: `\"PAHNAPLSIIGYIR\"`\nWrite the code that will take a string and make this conversion given a number of rows:\nstring convert(string s, int numRows);\n\nExample 1:\nInput: s = \"PAYPALISHIRING\", numRows = 3\nOutput: \"PAHNAPLSIIGYIR\"\n\nExample 2:\nInput: s = \"PAYPALISHIRING\", numRows = 4\nOutput: \"PINALSIGYAHRPI\"\nExplanation:\nP     I    N\nA   L S  I G\nY A   H R\nP     I\n\nExample 3:\nInput: s = \"A\", numRows = 1\nOutput: \"A\"\n\nConstraints:\n`1 <= s.length <= 1000`\n`s` consists of English letters (lower-case and upper-case), `','` and `'.'`.\n\n`1 <= numRows <= 1000`","body":"if (numRows == 1) return s var n = s.length var res = \"\" var cnt = numRows for (i in 0 until numRows) { cnt = if (cnt - 1 == 0) numRows-1 else cnt-1 var x = cnt*2 var j = i while (j < n) { res += s[j] j += x if ((numRows-1)*2-x != 0) x = (numRows-1)*2-x } } return res } }","difficulty":"medium"}
{"id":1584,"signature":"class Solution { fun find(x: Int): Int {","docstring":"You are given an array `points` representing integer coordinates of some points on a 2D-plane, where `points[i] = [xi, yi]`.\n\nThe cost of connecting two points `[xi, yi]` and `[xj, yj]` is the manhattan distance between them: `|xi - xj| + |yi - yj|`, where `|val|` denotes the absolute value of `val`.\n\nReturn the minimum cost to make all points connected. All points are connected if there is exactly one simple path between any two points.\n\n\nExample 1:\nInput: points = [[0,0],[2,2],[3,10],[5,2],[7,0]]\nOutput: 20\nExplanation:\nWe can connect the points as shown above to get the minimum cost of 20.\n\nNotice that there is a unique path between every pair of points.\n\n\nExample 2:\nInput: points = [[3,12],[-2,5],[-4,1]]\nOutput: 18\n\nExample 3:\nInput: points = [[0,0],[1,1],[1,0],[-1,1]]\nOutput: 4\n\nExample 4:\nInput: points = [[-1000000,-1000000],[1000000,1000000]]\nOutput: 4000000\n\nExample 5:\nInput: points = [[0,0]]\nOutput: 0\n\nConstraints:\n`1 <= points.length <= 1000`\n`-106 <= xi, yi <= 106`\nAll pairs `(xi, yi)` are distinct.","body":"import java.util.* import kotlin.math.abs class Solution { data class Node(var u: Int, var v: Int, var w: Int) companion object { val p = IntArray(1005) fun find(x: Int): Int { if (x != p[x]) p[x] = find(p[x]) return p[x] } } fun minCostConnectPoints(points: Array<IntArray>): Int { val n = points.size val q = PriorityQueue<Node> { x, y -> x.w - y.w } for (i in 0 until n) { for (j in i+1 until n) { q.add(Node(i, j, Math.abs(points[i][0]-points[j][0]) +Math.abs(points[i][1]-points[j][1]))) } } for (i in 0 until n) p[i] = i var res = 0 while(!q.isEmpty()) { val (x, y, w) = q.poll() val u = find(x) val v = find(y) if (u != v) { res += w p[u] = v } } return res } }","difficulty":"medium"}
{"id":60,"signature":"class Solution { fun getPermutation(n: Int, k: Int): String {","docstring":"The set `[1, 2, 3, ..., n]` contains a total of `n!` unique permutations.\n\nBy listing and labeling all of the permutations in order, we get the following sequence for `n = 3`:\n`\"123\"`\n`\"132\"`\n`\"213\"`\n`\"231\"`\n`\"312\"`\n`\"321\"`\nGiven `n` and `k`, return the `kth` permutation sequence.\n\n\nExample 1:\nInput: n = 3, k = 3\nOutput: \"213\"\n\nExample 2:\nInput: n = 4, k = 9\nOutput: \"2314\"\n\nExample 3:\nInput: n = 3, k = 1\nOutput: \"123\"\n\nConstraints:\n`1 <= n <= 9`\n`1 <= k <= n!`","body":"class Solution { private fun getsum(n: Int): Int{ var ans = 1 for (i in 2 .. n) ans *= i return ans } fun getPermutation(n: Int, k: Int): String { var vis = IntArray(n+1, {0}) var res = \"\" var tn = n var tk = k for (x in 0 until n) { val p = getsum(tn-1) var row = tk\/p if (tk != row*p) row++ var cnt = 0 var s = 0 for (i in 0 until n) if (vis[i] == 0) { cnt++ if (cnt == row) { vis[i] = 1 s = i+1 break; } } res += s.toString() tk =tk%p if (tk == 0) { tk = p } tn-- } return res } }","difficulty":"medium"}
{"id":14,"signature":"class Solution { fun longestCommonPrefix(strs: Array<String>): String {","docstring":"Write a function to find the longest common prefix string amongst an array of strings.\n\nIf there is no common prefix, return an empty string `\"\"`.\n\n\nExample 1:\nInput: strs = [\"flower\",\"flow\",\"flight\"]\nOutput: \"fl\"\n\nExample 2:\nInput: strs = [\"dog\",\"racecar\",\"car\"]\nOutput: \"\"\nExplanation: There is no common prefix among the input strings.\n\n\nConstraints:\n`0 <= strs.length <= 200`\n`0 <= strs[i].length <= 200`\n`strs[i]` consists of only lower-case English letters.","body":"if (strs.size == 0) return \"\" var len = 0 var res = \"\" for (j in 0 until strs[0].length) { val c = strs[0][j] for (i in 1 until strs.size) { if (j >= strs[i].length || strs[i][j] != c) { return res } } res += c } return res } }","difficulty":"easy"}
{"id":28,"signature":"class Solution { fun strStr(haystack: String, needle: String): Int {","docstring":"Implement strStr().\n\nReturn the index of the first occurrence of needle in haystack, or `-1` if `needle` is not part of `haystack`.\n\nClarification:\nWhat should we return when `needle` is an empty string? This is a great question to ask during an interview.\n\nFor the purpose of this problem, we will return 0 when `needle` is an empty string. This is consistent to C's strstr() and Java's indexOf().\n\n\nExample 1:\nInput: haystack = \"hello\", needle = \"ll\"\nOutput: 2\n\nExample 2:\nInput: haystack = \"aaaaa\", needle = \"bba\"\nOutput: -1\n\nExample 3:\nInput: haystack = \"\", needle = \"\"\nOutput: 0\n\nConstraints:\n`0 <= haystack.length, needle.length <= 5 * 104`\n`haystack` and `needle` consist of only lower-case English characters.","body":"if (needle == \"\") return 0 val n = haystack.length val m = needle.length for (i in 0 .. n-m) { for (j in 0 until m) { if (needle[j] != haystack[i+j]) break if (j == m-1) return i } } return -1 } }","difficulty":"easy"}
{"id":304,"signature":"class Solution { fun sumRegion(row1: Int, col1: Int, row2: Int, col2: Int): Int {","docstring":"Given a 2D matrix `matrix`, find the sum of the elements inside the rectangle defined by its upper left corner `(row1, col1)` and lower right corner `(row2, col2)`.\n\nImplement the NumMatrix class:\n`NumMatrix(int[][] matrix)` initializes the object with the integer matrix `matrix`.\n\n`int sumRegion(int row1, int col1, int row2, int col2)` returns the sum of the elements of the `matrix` array inside the rectangle defined by its upper left corner `(row1, col1)` and lower right corner `(row2, col2)`.\n\n\nExample 1:\nInput\n[\"NumMatrix\", \"sumRegion\", \"sumRegion\", \"sumRegion\"]\n[[[[3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5]]], [2, 1, 4, 3], [1, 1, 2, 2], [1, 2, 2, 4]]\nOutput\n[null, 8, 11, 12]\nExplanation\nNumMatrix numMatrix = new NumMatrix([[3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5]]);\nnumMatrix.sumRegion(2, 1, 4, 3); \/\/ return 8 (i.e sum of the red rectangele).\n\nnumMatrix.sumRegion(1, 1, 2, 2); \/\/ return 11 (i.e sum of the green rectangele).\n\nnumMatrix.sumRegion(1, 2, 2, 4); \/\/ return 12 (i.e sum of the blue rectangele).\n\n\nConstraints:\n`m == matrix.length`\n`n == matrix[i].length`\n`1 <= m, n <= 200`\n`-105 <= matrix[i][j] <= 105`\n`0 <= row1 <= row2 < m`\n`0 <= col1 <= col2 < n`\nAt most `104` calls will be made to `sumRegion`.","body":"class NumMatrix(matrix: Array<IntArray>) { var dp = Array(1005) { IntArray(1005) } init { for (i in 1 .. matrix.size) for (j in 1 .. matrix[0].size) dp[i][j] = dp[i][j-1]+dp[i-1][j]-dp[i-1][j-1]+matrix[i-1][j-1] } fun sumRegion(row1: Int, col1: Int, row2: Int, col2: Int): Int { return dp[row2+1][col2+1]-dp[row2+1][col1]-dp[row1][col2+1]+dp[row1][col1] } }","difficulty":"medium"}
{"id":1585,"signature":"class Solution { fun isTransformable(s: String, t: String): Boolean {","docstring":"Given two strings `s` and `t`, you want to transform string `s` into string `t` using the following operation any number of times:\nChoose a non-empty substring in `s` and sort it in-place so the characters are in ascending order.\n\nFor example, applying the operation on the underlined substring in `\"14234\"` results in `\"12344\"`.\n\nReturn `true` if it is possible to transform string `s` into string `t`. Otherwise, return `false`.\n\nA substring is a contiguous sequence of characters within a string.\n\n\nExample 1:\nInput: s = \"84532\", t = \"34852\"\nOutput: true\nExplanation: You can transform s into t using the following sort operations:\n\"84532\" (from index 2 to 3) -> \"84352\"\n\"84352\" (from index 0 to 2) -> \"34852\"\n\nExample 2:\nInput: s = \"34521\", t = \"23415\"\nOutput: true\nExplanation: You can transform s into t using the following sort operations:\n\"34521\" -> \"23451\"\n\"23451\" -> \"23415\"\n\nExample 3:\nInput: s = \"12345\", t = \"12435\"\nOutput: false\n\nExample 4:\nInput: s = \"1\", t = \"2\"\nOutput: false\n\nConstraints:\n`s.length == t.length`\n`1 <= s.length <= 105`\n`s` and `t` only contain digits from `'0'` to `'9'`.","body":"val idx = Array<MutableList<Int>>(10) { mutableListOf() } val pos = IntArray(10) for ((index, value) in s.withIndex()) { idx[value-'0'].add(index) } for ((index, value) in t.withIndex()) { val d = value-'0' if (pos[d] >= idx[d].size) return false for (j in 0 until d) { if (pos[j] < idx[j].size && idx[j][pos[j]] < idx[d][pos[d]]) return false } pos[d]++ } return true } }","difficulty":"hard"}
{"id":27,"signature":"class Solution { fun removeElement(nums: IntArray, `val`: Int): Int {","docstring":"Given an array nums and a value `val`, remove all instances of that value in-place and return the new length.\n\nDo not allocate extra space for another array, you must do this by modifying the input array in-place with `O(1)` extra memory.\n\nThe order of elements can be changed. It doesn't matter what you leave beyond the new length.\n\nClarification:\nConfused why the returned value is an integer but your answer is an array?\nNote that the input array is passed in by reference, which means a modification to the input array will be known to the caller as well.\n\nInternally you can think of this:\n\/\/ nums is passed in by reference. (i.e., without making a copy)\nint len = removeElement(nums, val);\n\/\/ any modification to nums in your function would be known by the caller.\n\n\/\/ using the length returned by your function, it prints the first len elements.\n\nfor (int i = 0; i < len; i++) {\n    print(nums[i]);\n}\n\nExample 1:\nInput: nums = [3,2,2,3], val = 3\nOutput: 2, nums = [2,2]\nExplanation: Your function should return length = 2, with the first two elements of nums being 2.\n\nIt doesn't matter what you leave beyond the returned length. For example if you return 2 with nums = [2,2,3,3] or nums = [2,2,0,0], your answer will be accepted.\n\n\nExample 2:\nInput: nums = [0,1,2,2,3,0,4,2], val = 2\nOutput: 5, nums = [0,1,4,0,3]\nExplanation: Your function should return length = `5`, with the first five elements of `nums` containing `0`, `1`, `3`, `0`, and 4. Note that the order of those five elements can be arbitrary. It doesn't matter what values are set beyond the returned length.\n\n\nConstraints:\n`0 <= nums.length <= 100`\n`0 <= nums[i] <= 50`\n`0 <= val <= 100`","body":"var res = 0 for (i in 0 until nums.size) { if (nums[i] != `val`) { nums[res++] = nums[i] } } return res } }","difficulty":"easy"}
{"id":24,"signature":"class Solution { fun swapPairs(head: ListNode?): ListNode? {","docstring":"Given a linked list, swap every two adjacent nodes and return its head.\n\n\nExample 1:\nInput: head = [1,2,3,4]\nOutput: [2,1,4,3]\n\nExample 2:\nInput: head = []\nOutput: []\n\nExample 3:\nInput: head = [1]\nOutput: [1]\n\nConstraints:\nThe number of nodes in the list is in the range `[0, 100]`.\n\n`0 <= Node.val <= 100`\nFollow up: Can you solve the problem without modifying the values in the list's nodes? (i.e., Only nodes themselves may be changed.)","body":"var G: ListNode? = ListNode(0) G?.next = head var p = G var head = head while (head != null && head.next != null) { var temp = head?.next head?.next = temp.next temp?.next = head p?.next = temp p = head head = head?.next } return G?.next } }","difficulty":"medium"}
{"id":1405,"signature":"class Solution { fun longestDiverseString(a: Int, b: Int, c: Int): String {","docstring":"A string is called happy if it does not have any of the strings `'aaa'`, `'bbb'` or `'ccc'` as a substring.\n\nGiven three integers `a`, `b` and `c`, return any string `s`, which satisfies following conditions:\n`s` is happy and longest possible.\n\n`s` contains at most `a` occurrences of the letter `'a'`, at most `b` occurrences of the letter `'b'` and at most `c` occurrences of the letter `'c'`.\n\n`s `will only contain `'a'`, `'b'` and `'c'` letters.\n\nIf there is no such string `s` return the empty string `\"\"`.\n\n\nExample 1:\nInput: a = 1, b = 1, c = 7\nOutput: \"ccaccbcc\"\nExplanation: \"ccbccacc\" would also be a correct answer.\n\n\nExample 2:\nInput: a = 2, b = 2, c = 1\nOutput: \"aabbc\"\n\nExample 3:\nInput: a = 7, b = 1, c = 0\nOutput: \"aabaa\"\nExplanation: It's the only correct answer in this case.\n\n\nConstraints:\n`0 <= a, b, c <= 100`\n`a + b + c > 0`","body":"val total = a + b + c val f = intArrayOf(a, b, c) val l = IntArray(3) var res = \"\" for (x in 0 until total) { for (i in 0 until 3) { val j = (i+1)%3 val k = (i+2)%3 if ((f[i] >= f[j] && f[i] >= f[k] && l[i] != 2) || (f[i] > 0 && (l[j] == 2 || l[k] == 2))) { res += 'a' + i l[i]++ f[i]-- l[j] = 0 l[k] = 0 break } } } return res } }","difficulty":"medium"}
{"id":1,"signature":"class Solution { fun twoSum(nums: IntArray, target: Int): IntArray {","docstring":"Given an array of integers `nums` and an integer `target`, return indices of the two numbers such that they add up to `target`.\n\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\n\nYou can return the answer in any order.\n\n\nExample 1:\nInput: nums = [2,7,11,15], target = 9\nOutput: [0,1]\nOutput: Because nums[0] + nums[1] == 9, we return [0, 1].\n\nExample 2:\nInput: nums = [3,2,4], target = 6\nOutput: [1,2]\n\nExample 3:\nInput: nums = [3,3], target = 6\nOutput: [0,1]\n\nConstraints:\n`2 <= nums.length <= 103`\n`-109 <= nums[i] <= 109`\n`-109 <= target <= 109`\nOnly one valid answer exists.","body":"val mm = HashMap<Int, Int>() var res = mutableListOf<Int>() for (i in nums.indices) { mm[nums[i]] = i } for (i in nums.indices) { val temp = mm.get(target - nums[i]) if (temp != null && (temp ?: -1) > i) { res.add(i) res.add(mm.getOrElse(target-nums[i], {0})) } } return res.toIntArray() } }","difficulty":"easy"}
{"id":859,"signature":"class Solution { fun buddyStrings(A: String, B: String): Boolean {","docstring":"Given two strings `a` and `b`, return `true` if you can swap two letters in `a` so the result is equal to `b`, otherwise, return `false`.\n\nSwapping letters is defined as taking two indices `i` and `j` (0-indexed) such that `i != j` and swapping the characters at `a[i]` and `b[j]`. For example, swapping at indices `0` and `2` in `\"abcd\"` results in `\"cbad\"`.\n\n\nExample 1:\nInput: a = \"ab\", b = \"ba\"\nOutput: true\nExplanation: You can swap a[0] = 'a' and a[1] = 'b' to get \"ba\", which is equal to b.\n\n\nExample 2:\nInput: a = \"ab\", b = \"ab\"\nOutput: false\nExplanation: The only letters you can swap are a[0] = 'a' and a[1] = 'b', which results in \"ba\" != b.\n\n\nExample 3:\nInput: a = \"aa\", b = \"aa\"\nOutput: true\nExplanation: You can swap a[0] = 'a' and a[1] = 'a' to get \"aa\", which is equal to b.\n\n\nExample 4:\nInput: a = \"aaaaaaabc\", b = \"aaaaaaacb\"\nOutput: true\n\nConstraints:\n`1 <= a.length, b.length <= 2 * 104`\n`a` and `b` consist of lowercase letters.","body":"class Solution { private fun judge(A: String, B: String): Boolean{ if ((A == B && A[0] == A[1]) || (A != B && A[0] == B[1] && A[1] == B[0])) return true return false } fun buddyStrings(A: String, B: String): Boolean { if (A.length != B.length || A.length < 2 || B.length < 2) return false var diff = 0 var st1 = \"\" var st2 = \"\" for (i in 0 until A.length) { if (A[i] != B[i]) { diff++ st1 += A[i] st2 += B[i] } } if (diff == 1 || diff > 2) return false else if (diff == 2) return judge(st1, st2) else { var nums = IntArray(30) for (i in 0 until A.length) { nums[A[i]-'a']++ if (nums[A[i]-'a'] >= 2) return true } return false } } }","difficulty":"easy"}
{"id":104,"signature":"class Solution { fun maxDepth(root: TreeNode?): Int {","docstring":"Given the `root` of a binary tree, return its maximum depth.\n\nA binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.\n\n\nExample 1:\nInput: root = [3,9,20,null,null,15,7]\nOutput: 3\n\nExample 2:\nInput: root = [1,null,2]\nOutput: 2\n\nExample 3:\nInput: root = []\nOutput: 0\n\nExample 4:\nInput: root = [0]\nOutput: 1\n\nConstraints:\nThe number of nodes in the tree is in the range `[0, 104]`.\n\n`-100 <= Node.val <= 100`","body":"class Solution { var res = 0 fun maxDepth(root: TreeNode?): Int { if (root == null) return 0 val left = maxDepth(root.left) val right = maxDepth(root.right) return if (left >= right) left+1 else right+1 } }","difficulty":"easy"}
{"id":70,"signature":"class Solution { fun climbStairs(n: Int): Int {","docstring":"You are climbing a staircase. It takes `n` steps to reach the top.\n\nEach time you can either climb `1` or `2` steps. In how many distinct ways can you climb to the top?\n\nExample 1:\nInput: n = 2\nOutput: 2\nExplanation: There are two ways to climb to the top.\n\n1. 1 step + 1 step\n2. 2 steps\n\nExample 2:\nInput: n = 3\nOutput: 3\nExplanation: There are three ways to climb to the top.\n\n1. 1 step + 1 step + 1 step\n2. 1 step + 2 steps\n3. 2 steps + 1 step\n\nConstraints:\n`1 <= n <= 45`","body":"var dp = IntArray(55, {0}) dp[1] = 1 dp[2] = 2 (3 .. n).forEach { i -> dp[i] = dp[i-1]+dp[i-2] } return dp[n] } }","difficulty":"easy"}
{"id":621,"signature":"class Solution { fun leastInterval(tasks: CharArray, n: Int): Int {","docstring":"Given a characters array `tasks`, representing the tasks a CPU needs to do, where each letter represents a different task. Tasks could be done in any order. Each task is done in one unit of time. For each unit of time, the CPU could complete either one task or just be idle.\n\nHowever, there is a non-negative integer `n` that represents the cooldown period between two same tasks (the same letter in the array), that is that there must be at least `n` units of time between any two same tasks.\n\nReturn the least number of units of times that the CPU will take to finish all the given tasks.\n\n\nExample 1:\nInput: tasks = [\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"], n = 2\nOutput: 8\nExplanation: \nA -> B -> idle -> A -> B -> idle -> A -> B\nThere is at least 2 units of time between any two same tasks.\n\n\nExample 2:\nInput: tasks = [\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"], n = 0\nOutput: 6\nExplanation: On this case any permutation of size 6 would work since n = 0.\n\n[\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"]\n[\"A\",\"B\",\"A\",\"B\",\"A\",\"B\"]\n[\"B\",\"B\",\"B\",\"A\",\"A\",\"A\"]\n...\n\nAnd so on.\n\n\nExample 3:\nInput: tasks = [\"A\",\"A\",\"A\",\"A\",\"A\",\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\"], n = 2\nOutput: 16\nExplanation: \nOne possible solution is\nA -> B -> C -> A -> D -> E -> A -> F -> G -> A -> idle -> idle -> A -> idle -> idle -> A\n\nConstraints:\n`1 <= task.length <= 104`\n`tasks[i]` is upper-case English letter.\n\nThe integer `n` is in the range `[0, 100]`.","body":"var cnt = IntArray(26) for (i in tasks) cnt[i-'A']++ cnt.sort() var x = 25 var mx = cnt[25] while (x >= 0 && cnt[x] == mx) x-- return Math.max(tasks.size, (mx-1)*(n+1)+25-x) } }","difficulty":"medium"}
{"id":69,"signature":"class Solution { fun mySqrt(x: Int): Int {","docstring":"Given a non-negative integer `x`, compute and return the square root of `x`.\n\nSince the return type is an integer, the decimal digits are truncated, and only the integer part of the result is returned.\n\n\nExample 1:\nInput: x = 4\nOutput: 2\n\nExample 2:\nInput: x = 8\nOutput: 2\nExplanation: The square root of 8 is 2.82842..., and since the decimal part is truncated, 2 is returned.\n\n\nConstraints:\n`0 <= x <= 231 - 1`","body":"var l: Long = 0 var r: Long = x.toLong() var mid: Long var ans: Long = 0 while (l <= r) { mid = (l+r)\/2 if (mid*mid == x.toLong()) { return mid.toInt() } if (mid*mid > x) { r = mid-1 } else { ans = Math.max(ans, mid) l = mid+1 } } return ans.toInt() } }","difficulty":"easy"}
