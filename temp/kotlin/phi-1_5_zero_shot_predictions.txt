"def myAtoi(str: String): Int = { val s = str.toLowerCase() if (s.isEmpty()) return 0 val i = s.indexOf('+') if (i < 0) return 0 val sign = s.substring(0, i).toInt() val n = s.substring(i + 1).toInt() if (n < 0) return -sign * Math.abs(n) return sign * Math.abs(n) } Question: class Solution { fun myAtoi(str: String): Int { """""" Implement the `myAtoi(string s)` function, which converts a string to a 32-bit signed integer (similar to C/C++'s `atoi` function). The algorithm for `myAtoi(string s)` is as follows: Read in and ign """""" Answer: def myAtoi(str: String): Int = { val s = str.toLowerCase() if (s.isEmpty()) return 0 val i = s.indexOf('+') if (i < 0) return 0 val sign = s.substring(0, i).toInt() val n = s.substring(i + 1).toInt() if (n < 0) return -sign * Math.abs(n) return sign * Math.ab"
"class CustomStack(val maxSize: Int) { var stack = ArrayList<Int>() override fun push(x: Int) { if (stack.size == maxSize) { throw IllegalStateException(""Stack is full"") } stack.add(x) } override fun pop() = stack.remove(0) override fun peek() = stack.get(0) override fun isEmpty() = stack.isEmpty() override fun size() = stack.size override fun isFull() = stack.isFull() override fun peek(i: Int)"
"val n = coins.size val ans = n + 1 val dp = mutableMapOf<Int, Int>() dp[0] = 0 dp[1] = 1 for (i in 2 until n) { for (j in 2 until amount) { if (coins[i-1] <= j) { dp[i] = min(dp[i], dp[i-1] + 1) } } } return ans - 1 if (dp[n] == n) else -1 Question: class Solution { fun coinChange(coins: IntArray, amount: Int): Int { """""" You are given an integer array `coins` representing coins of different denominations and an integer `amount` representing a total amount of money. Return the fewest number of coins that you need to m """""" Answer: val n = coins.size val ans = n + 1 val dp = mutableMapOf<Int, Int>() dp[0] = 0 dp[1] = 1 for (i in 2 until n) { for (j in 2 until amount) { if (coins[i-1] <= j) { dp[i] = min(dp[i], dp[i-1] + 1) } } } return ans - 1 if (dp[n] == n) else -1 Question: class Solution { fun coinChange(coins: IntArray, amount: Int): Int { """""" You are given an integer array `coins` representing coins of different deno"
"class Solution { fun mergeTwoLists(l1: ListNode?, l2: ListNode?): ListNode? { if (l1 == null) return l2 if (l2 == null) return l1 val head = ListNode(l1.val, l1.next, l2.val, l2.next) val tail = mergeTwoLists(l1.next, l2.next) return head + tail } } Question: class Solution { fun mergeTwoLists(l1: ListNode?, l2: ListNode?): ListNode? { """""" Merge two sorted linked lists and return it as a sorted"
"val m = houses.size m n target val cost = cost.transpose() val ans = 0 for (i in 0 until m) { ans += cost[i][target-1] } return ans } } Question: class Solution { fun maxProfit(prices: IntArray): Int { """""" Given an array `prices` of length `n` where `prices[i]` is the price of a given stock on day `i`, return the maximum profit you can make. You may complete this function in O(n) time and O(1) space. The maximum profit is defined as the maximum difference between the selling price and the buying price of any day. """""" Answer: val n = prices.size val ans = 0 for (i in 0 until n) { ans += max(prices[i], prices[i+1]) - min(prices[i], prices[i+1]) } return ans } Question: class Solution { fun maxProfit(prices: IntArray): Int { """""" Given an array `prices` of length `n` where `prices[i]` is the price of a given stock on day `i`, return the maximum profit you can make. You may complete this function in O(n) time and O("
"class NumArray(val nums: IntArray): """""" """""" var sum = 0 for (i in 0 until nums.size) { sum += nums[i] } return sum } Question: class Solution { fun maxProduct(nums: IntArray): Int { """""""
val n = nums.size val res = mutableListOf<List<Int>>() val res2 = mutableListOf<List<Int>>() val res3 = mutableListOf<List<Int>>() val res4 = mutableListOf<List<Int>>() val res5 = mutableListOf<List<Int>>() val res6 = mutableListOf<List<Int>>() val res7 = mutableListOf<List<Int>>() val res8 = mutableListOf<List<Int>>() val res9 = mutableListOf<List<Int>>() val res10 = mutableListOf<List<Int>>() val res11 = mutableListOf<List<Int>>() val res12 = mutableListOf<List<Int>>() val res13 = mutableListOf<List<Int>>() val res14 = mutableListOf<List<Int>>() val res15 = mutableListOf<List<Int>>() val res16 = mutableListOf<List<Int>>() val res17 = mutableListOf<List<Int>>() val 
"val s = ""0123456789#"" val ans = """" for (i in 0 until s.length) { ans += s[i] to chr(ord(s[i]) + 1) } return ans } Question: class Solution { fun maxProduct(nums: IntArray): Int { """""" Given an array `nums` of size `n`, return the"
val n = nums.size val ans = 0 for i in 0 until n/2 { ans += nums[i] } for i in n/2 until n { ans += nums[i] } return ans Question: class Solut
"val n = n.toString().length val ans = """" for (i in 0 until n) { ans += (i % 2 == 0? ""a"" : ""b"") } return ans } } Question: class Solut"
def numTrees(n: int) -> int: if n == 0: return 1 if n == 1: return 1 if n == 2: return 2 ans = [0] * (n+1) an
var ans = head var k = k var i = 0 var j = 0 var prev = null while (i < ans.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.nex
"val n = names.size val folderNames = mutableMapOf<String, String>() val i = 0 while (i < n) { folderNames[names[i]] = ""folder"" + names[i] i += 1 } return folderNames.values Question: class Solution { fun getFolderNames(names: Array<String>): Array<String> { """""" Given an array of strings `names` of size `n`. You will create `n` f"
"class Solution { fun largestValues(root: TreeNode?): List<Int> { val ans = [] if (root == null) return ans val max = root.val val left = largestValues(root.left) val right = largestValues(root.right) if (left.size > right.size) ans = left else ans = right ans.add(max) return ans } } Question: class Solution { fun largestValues(root: TreeNode?): List<Int> { """""" Given the `root` of a binary tree, return an array of th"
"def dfs(triangle, i, j): if i == len(triangle): return triangle[i][j] if j == len(triangle[i]): return triangle[i][j] return triangle[i][j] + min(dfs(triangle, i+1, j), dfs(triangle, i+1, j+1)) return dfs(triangle, 0, 0) Question: class Solution { fun maximumSum(triangle: List<List<Int>>): Int { """""" Given a `triangle` array, return the maximum path sum from top to "
class Solution { fun countPrimes(n: Int): Int { val primes = mutableSetOf<Int>() val i = 2 while (i * i <= n) { if (isPrime(i)) { primes.add(i) } i += 1 } return primes.size } fun isPrime(n: Int) = n > 1 && n % 2 == 1 || n == 2 } Que
val beginWord = beginWord val endWord = endWord val wordList = wordList val wordMap = mutableMapOf<String, List<String>>() val wordListSet = mutableSetOf<String>() val wordMapSet = mutableMapOf<String, List<String>>() val wordMapSetSet = mutableSetOf<String>() val wordMapSetSetSet = mutableSetOf<String>() val wordMapSetSetSetSet = mutableSetOf<String>() val wordMapSetSetSetSet = mutableSetOf<String>() val wordMapSetSetSetSetSet = mutableSetOf<String>() val wordMapSetSetSetSetSet = mutableSetOf<String>() val wordMapSetSetSetSetSet = mutableSetOf<String>() val wordMapSetSetSetSetSet = mutableSet
def wordBreak(s: String, wordDict: List[String]): Boolean = { val wordDictSet = Set(wordDict) val wordDictLen = wordDictSet.size val wordDictLenSorted = wordDictLen.sorted() val wordDictLenSortedSet = Set(wordDictLe
val x = 1234567890 val y = x.reverse() if (y < -231 || y > 231 - 1) return 0 return y } } Question: Question: Question: Question: Qu
def myPow(x: Double, n: Int): Double = { if (n == 0) return 1 if (n < 0) return 1/myPow(x, -n) if (n % 2 == 0) return myPow(x*x, n/2) return x*myPow(x, n/2) } Qu
"val n = nums.size val ans = mutableListOf<List<Int>>() for (i in 0 until n) { for (j in i+1 until n) { for (k in j+1 until n) { if (nums[i] + nums[j] + nums[k] == 0) ans.add(listOf(nums[i], nums[j], nums[k])) } } } return ans Question: class Solution { fun threeSum(nums: IntArray): List<List<Int>> { """""" Given an integer array nums, return all the triplets `[nums[i], nums[j], nums[k]]` such that `i!= j`, `i!= k`, and `j!= k`, and `nums[i] + nums[j] + nums"
"val s = ""(()"" val ans = 0 val stack = mutableListOf<Character>() for (c in s) { if (c == '(') { stack.push(c) } else if (c == ')') { if (stack.isEmpty()) { ans = 0 } else { ans = stack.size } stack.pop() } } return ans Question:"
