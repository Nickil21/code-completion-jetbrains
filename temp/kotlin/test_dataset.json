{"id":8,"signature":"class Solution { fun myAtoi(str: String): Int {","docstring":"Implement the `myAtoi(string s)` function, which converts a string to a 32-bit signed integer (similar to C\/C++'s `atoi` function).\n\nThe algorithm for `myAtoi(string s)` is as follows:\nRead in and ignore any leading whitespace.\n\nCheck if the next character (if not already at the end of the string) is `'-'` or `'+'`. Read this character in if it is either. This determines if the final result is negative or positive respectively. Assume the result is positive if neither is present.\n\nRead in next the characters until the next non-digit charcter or the end of the input is reached. The rest of the string is ignored.\n\nConvert these digits into an integer (i.e. `\"123\" -> 123`, `\"0032\" -> 32`). If no digits were read, then the integer is `0`. Change the sign as necessary (from step 2).\n\nIf the integer is out of the 32-bit signed integer range `[-231, 231 - 1]`, then clamp the integer so that it remains in the range. Specifically, integers less than `-231` should be clamped to `-231`, and integers greater than `231 - 1` should be clamped to `231 - 1`.\n\nReturn the integer as the final result.\n\nNote:\nOnly the space character `' '` is considered a whitespace character.\n\nDo not ignore any characters other than the leading whitespace or the rest of the string after the digits.\n\n\nExample 1:\nInput: s = \"42\"\nOutput: 42\nExplanation: The underlined characters are what is read in, the caret is the current reader position.\n\nStep 1: \"42\" (no characters read because there is no leading whitespace)\n         ^\nStep 2: \"42\" (no characters read because there is neither a '-' nor '+')\n         ^\nStep 3: \"42\" (\"42\" is read in)\n           ^\nThe parsed integer is 42.\n\nSince 42 is in the range [-231, 231 - 1], the final result is 42.\n\n\nExample 2:\nInput: s = \"   -42\"\nOutput: -42\nExplanation:\nStep 1: \"   -42\" (leading whitespace is read and ignored)\n            ^\nStep 2: \"   -42\" ('-' is read, so the result should be negative)\n             ^\nStep 3: \"   -42\" (\"42\" is read in)\n               ^\nThe parsed integer is -42.\n\nSince -42 is in the range [-231, 231 - 1], the final result is -42.\n\n\nExample 3:\nInput: s = \"4193 with words\"\nOutput: 4193\nExplanation:\nStep 1: \"4193 with words\" (no characters read because there is no leading whitespace)\n         ^\nStep 2: \"4193 with words\" (no characters read because there is neither a '-' nor '+')\n         ^\nStep 3: \"4193 with words\" (\"4193\" is read in; reading stops because the next character is a non-digit)\n             ^\nThe parsed integer is 4193.\n\nSince 4193 is in the range [-231, 231 - 1], the final result is 4193.\n\n\nExample 4:\nInput: s = \"words and 987\"\nOutput: 0\nExplanation:\nStep 1: \"words and 987\" (no characters read because there is no leading whitespace)\n         ^\nStep 2: \"words and 987\" (no characters read because there is neither a '-' nor '+')\n         ^\nStep 3: \"words and 987\" (reading stops immediately because there is a non-digit 'w')\n         ^\nThe parsed integer is 0 because no digits were read.\n\nSince 0 is in the range [-231, 231 - 1], the final result is 0.\n\n\nExample 5:\nInput: s = \"-91283472332\"\nOutput: -2147483648\nExplanation:\nStep 1: \"-91283472332\" (no characters read because there is no leading whitespace)\n         ^\nStep 2: \"-91283472332\" ('-' is read, so the result should be negative)\n          ^\nStep 3: \"-91283472332\" (\"91283472332\" is read in)\n                     ^\nThe parsed integer is -91283472332.\n\nSince -91283472332 is less than the lower bound of the range [-231, 231 - 1], the final result is clamped to -231 = -2147483648. \n\nConstraints:\n`0 <= s.length <= 200`\n`s` consists of English letters (lower-case and upper-case), digits (`0-9`), `' '`, `'+'`, `'-'`, and `'.'`.","body":"var ans = arrayListOf<Int>() var first = false var flag = 1 var pos = 0 for (i in 0 until str.length) { if (str[i] != ' ') { if (str[i] in '0' .. '9' || str[i] == '-' || str[i] == '+') { if (str[i] == '-') flag = -1 first = true pos = i } break } } if (!first) { return 0 } else { pos = if (str[pos] == '-' || str[pos] == '+') pos+1 else pos while (pos < str.length && str[pos] == '0') pos++ while (pos < str.length && str[pos] in '0'..'9') { ans.add(str[pos]-'0') pos++ } var cnt: Long = 1 var res: Long = 0 if (ans.size > 10) { return if (flag == -1) -2147483648 else 2147483647 } for (i in ans.size-1 downTo 0) { res += ans[i]*cnt cnt *= 10 if (res >= Int.MAX_VALUE) break } res *= flag if (res < Int.MIN_VALUE) res = -2147483648 if (res > Int.MAX_VALUE) res = 2147483647 return res.toInt() } } }","difficulty":"medium"}
{"id":1381,"signature":"class Solution { fun push(x: Int) {","docstring":"Design a stack which supports the following operations.\n\nImplement the `CustomStack` class:\n`CustomStack(int maxSize)` Initializes the object with `maxSize` which is the maximum number of elements in the stack or do nothing if the stack reached the `maxSize`.\n\n`void push(int x)` Adds `x` to the top of the stack if the stack hasn't reached the `maxSize`.\n\n`int pop()` Pops and returns the top of stack or -1 if the stack is empty.\n\n`void inc(int k, int val)` Increments the bottom `k` elements of the stack by `val`. If there are less than `k` elements in the stack, just increment all the elements in the stack.\n\n\nExample 1:\nInput\n[\"CustomStack\",\"push\",\"push\",\"pop\",\"push\",\"push\",\"push\",\"increment\",\"increment\",\"pop\",\"pop\",\"pop\",\"pop\"]\n[[3],[1],[2],[],[2],[3],[4],[5,100],[2,100],[],[],[],[]]\nOutput\n[null,null,null,2,null,null,null,null,null,103,202,201,-1]\nExplanation\nCustomStack customStack = new CustomStack(3); \/\/ Stack is Empty []\ncustomStack.push(1);                          \/\/ stack becomes [1]\ncustomStack.push(2);                          \/\/ stack becomes [1, 2]\ncustomStack.pop();                            \/\/ return 2 --> Return top of the stack 2, stack becomes [1]\ncustomStack.push(2);                          \/\/ stack becomes [1, 2]\ncustomStack.push(3);                          \/\/ stack becomes [1, 2, 3]\ncustomStack.push(4);                          \/\/ stack still [1, 2, 3], Don't add another elements as size is 4\ncustomStack.increment(5, 100);                \/\/ stack becomes [101, 102, 103]\ncustomStack.increment(2, 100);                \/\/ stack becomes [201, 202, 103]\ncustomStack.pop();                            \/\/ return 103 --> Return top of the stack 103, stack becomes [201, 202]\ncustomStack.pop();                            \/\/ return 202 --> Return top of the stack 102, stack becomes [201]\ncustomStack.pop();                            \/\/ return 201 --> Return top of the stack 101, stack becomes []\ncustomStack.pop();                            \/\/ return -1 --> Stack is empty return -1.\n\n\nConstraints:\n`1 <= maxSize <= 1000`\n`1 <= x <= 1000`\n`1 <= k <= 1000`\n`0 <= val <= 100`\nAt most `1000` calls will be made to each method of `increment`, `push` and `pop` each separately.","body":"class CustomStack(maxSize: Int) { private var stk: IntArray private var size: Int private var top: Int init { this.size = maxSize this.top = 0 this.stk = IntArray(maxSize+1) } fun push(x: Int) { if (top+1 <= size) { stk[top+1] = x top++ } } fun pop(): Int { if (top == 0) return -1 return stk[top--]; } fun increment(k: Int, `val`: Int) { for (i in 0 .. Math.min(size, k)) { stk[i] += `val` } } }","difficulty":"medium"}
{"id":322,"signature":"class Solution { fun coinChange(coins: IntArray, amount: Int): Int {","docstring":"You are given an integer array `coins` representing coins of different denominations and an integer `amount` representing a total amount of money.\n\nReturn the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return `-1`.\n\nYou may assume that you have an infinite number of each kind of coin.\n\n\nExample 1:\nInput: coins = [1,2,5], amount = 11\nOutput: 3\nExplanation: 11 = 5 + 5 + 1\n\nExample 2:\nInput: coins = [2], amount = 3\nOutput: -1\n\nExample 3:\nInput: coins = [1], amount = 0\nOutput: 0\n\nExample 4:\nInput: coins = [1], amount = 1\nOutput: 1\n\nExample 5:\nInput: coins = [1], amount = 2\nOutput: 2\n\nConstraints:\n`1 <= coins.length <= 12`\n`1 <= coins[i] <= 231 - 1`\n`0 <= amount <= 104`","body":"import java.util.LinkedList  var dp = IntArray(amount+1) {0x3f3f3f3f} dp[0] = 0 for (i in coins) { for (j in i .. amount) { if (dp[j-i] != 0x3f3f3f3f) { dp[j] = Math.min(dp[j], dp[j-i]+1) } } } return if (dp[amount] == 0x3f3f3f3f) -1 else dp[amount] } data class Node( var num: Int = 0, var step: Int = 0 ) fun coinChange2(coins: IntArray, amount: Int): Int { val n = coins.size var dp = BooleanArray(amount+1) dp[0] = true for (i in 0 until n) { for (j in 0 .. amount) { if (j <= amount-coins[i]) { if (dp[j]) { dp[j+coins[i]] = true } } } } if (dp[amount]) { var q = LinkedList<Node>() var vis = BooleanArray(amount+1) q.offer(Node(0, 0)) vis[0] = true while (!q.isEmpty()) { val top = q.poll() if (top.num == amount) return top.step for (i in 0 until n) { if (top.num <= amount-coins[i] && !vis[top.num+coins[i]]) { q.offer(Node(top.num+coins[i], top.step+1)) vis[top.num+coins[i]] = true } } } return -1 } else { return -1; } } }","difficulty":"medium"}
{"id":21,"signature":"class Solution { fun mergeTwoLists(l1: ListNode?, l2: ListNode?): ListNode? {","docstring":"Merge two sorted linked lists and return it as a sorted list. The list should be made by splicing together the nodes of the first two lists.\n\n\nExample 1:\nInput: l1 = [1,2,4], l2 = [1,3,4]\nOutput: [1,1,2,3,4,4]\n\nExample 2:\nInput: l1 = [], l2 = []\nOutput: []\n\nExample 3:\nInput: l1 = [], l2 = [0]\nOutput: [0]\n\nConstraints:\nThe number of nodes in both lists is in the range `[0, 50]`.\n\n`-100 <= Node.val <= 100`\nBoth `l1` and `l2` are sorted in non-decreasing order.","body":"val result = ListNode(0) var current = result var node1 = list1 var node2 = list2 while (node1 != null || node2 != null) { if (node1 == null) { current.next = node2 break } if (node2 == null) { current.next = node1 break } if (node1.`val` < node2.`val`) { current.next = node1 node1 = node1.next } else { current.next = node2 node2 = node2.next } current = current.next!! } return result?.next } }","difficulty":"easy"}
{"id":1473,"signature":"class Solution { fun minCost(houses: IntArray, cost: Array<IntArray>, m: Int, n: Int, target: Int): Int {","docstring":"There is a row of `m` houses in a small city, each house must be painted with one of the `n` colors (labeled from `1` to `n`), some houses that have been painted last summer should not be painted again.\n\nA neighborhood is a maximal group of continuous houses that are painted with the same color.\n\nFor example: `houses = [1,2,2,3,3,2,1,1]` contains `5` neighborhoods `[{1}, {2,2}, {3,3}, {2}, {1,1}]`.\n\nGiven an array `houses`, an `m x n` matrix `cost` and an integer `target` where:\n`houses[i]`: is the color of the house `i`, and `0` if the house is not painted yet.\n\n`cost[i][j]`: is the cost of paint the house `i` with the color `j + 1`.\n\nReturn the minimum cost of painting all the remaining houses in such a way that there are exactly `target` neighborhoods. If it is not possible, return `-1`.\n\n\nExample 1:\nInput: houses = [0,0,0,0,0], cost = [[1,10],[10,1],[10,1],[1,10],[5,1]], m = 5, n = 2, target = 3\nOutput: 9\nExplanation: Paint houses of this way [1,2,2,1,1]\nThis array contains target = 3 neighborhoods, [{1}, {2,2}, {1,1}].\n\nCost of paint all houses (1 + 1 + 1 + 1 + 5) = 9.\n\n\nExample 2:\nInput: houses = [0,2,1,2,0], cost = [[1,10],[10,1],[10,1],[1,10],[5,1]], m = 5, n = 2, target = 3\nOutput: 11\nExplanation: Some houses are already painted, Paint the houses of this way [2,2,1,2,2]\nThis array contains target = 3 neighborhoods, [{2,2}, {1}, {2,2}]. \nCost of paint the first and last house (10 + 1) = 11.\n\n\nExample 3:\nInput: houses = [0,0,0,0,0], cost = [[1,10],[10,1],[1,10],[10,1],[1,10]], m = 5, n = 2, target = 5\nOutput: 5\n\nExample 4:\nInput: houses = [3,1,2,3], cost = [[1,1,1],[1,1,1],[1,1,1],[1,1,1]], m = 4, n = 3, target = 3\nOutput: -1\nExplanation: Houses are already painted with a total of 4 neighborhoods [{3},{1},{2},{3}] different of target = 3.\n\n\nConstraints:\n`m == houses.length == cost.length`\n`n == cost[i].length`\n`1 <= m <= 100`\n`1 <= n <= 20`\n`1 <= target <= m`\n`0 <= houses[i] <= n`\n`1 <= cost[i][j] <= 10^4`","body":"val dp = Array<Array<Array<Int>>>(m){Array<Array<Int>>(n+1){Array<Int>(target+1) { Int.MAX_VALUE }}} if (houses[0] == 0) { for (i in 1 .. n) dp[0][i][0] = cost[0][i-1] } else { dp[0][houses[0]][0] = 0 } for (i in 1 until m) { for (j in 1 .. n) { for (k in 0 until target) { if (houses[i] == 0) { for (j_old in 1 .. n) { if (dp[i-1][j_old][k] == Int.MAX_VALUE) continue if (j_old == j) { dp[i][j][k] = Math.min(dp[i - 1][j_old][k] + cost[i][j - 1], dp[i][j][k]) } else { dp[i][j][k + 1] = Math.min(dp[i - 1][j_old][k] + cost[i][j - 1], dp[i][j][k + 1]) } } } else { if (dp[i - 1][j][k] == Int.MAX_VALUE) continue if (houses[i] == j) { dp[i][j][k] = Math.min(dp[i - 1][j][k], dp[i][j][k]) } else { dp[i][houses[i]][k + 1] = Math.min(dp[i - 1][j][k], dp[i][houses[i]][k + 1]) } } } } } var ans = Int.MAX_VALUE for (j in 1 .. n) { ans = Math.min(ans, dp[m - 1][j][target - 1]) } return if (ans == Int.MAX_VALUE) -1 else ans; } }","difficulty":"hard"}
{"id":303,"signature":"class Solution { fun sumRange(i: Int, j: Int): Int {","docstring":"Given an integer array `nums`, find the sum of the elements between indices `left` and `right` inclusive, where `(left <= right)`.\n\nImplement the `NumArray` class:\n`NumArray(int[] nums)` initializes the object with the integer array `nums`.\n\n`int sumRange(int left, int right)` returns the sum of the elements of the `nums` array in the range `[left, right]` inclusive (i.e., `sum(nums[left], nums[left + 1], ... , nums[right])`).\n\n\nExample 1:\nInput\n[\"NumArray\", \"sumRange\", \"sumRange\", \"sumRange\"]\n[[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]\nOutput\n[null, 1, -1, -3]\nExplanation\nNumArray numArray = new NumArray([-2, 0, 3, -5, 2, -1]);\nnumArray.sumRange(0, 2); \/\/ return 1 ((-2) + 0 + 3)\nnumArray.sumRange(2, 5); \/\/ return -1 (3 + (-5) + 2 + (-1)) \nnumArray.sumRange(0, 5); \/\/ return -3 ((-2) + 0 + 3 + (-5) + 2 + (-1))\n\nConstraints:\n`1 <= nums.length <= 104`\n`-105 <= nums[i] <= 105`\n`0 <= left <= right < nums.length`\nAt most `104` calls will be made to `sumRange`.","body":"class NumArray(nums: IntArray) { var dp = IntArray(nums.size+1) init { for (i in 1 .. nums.size) dp[i] = dp[i-1]+nums[i-1] } fun sumRange(i: Int, j: Int): Int { return dp[j+1]-dp[i] } }","difficulty":"easy"}
{"id":18,"signature":"class Solution { fun fourSum(nums: IntArray, target: Int): List<List<Int>> {","docstring":"Given an array `nums` of n integers and an integer `target`, are there elements a, b, c, and d in `nums` such that a + b + c + d = `target`? Find all unique quadruplets in the array which gives the sum of `target`.\n\nNotice that the solution set must not contain duplicate quadruplets.\n\n\nExample 1:\nInput: nums = [1,0,-1,0,-2,2], target = 0\nOutput: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]\n\nExample 2:\nInput: nums = [], target = 0\nOutput: []\n\nConstraints:\n`0 <= nums.length <= 200`\n`-109 <= nums[i] <= 109`\n`-109 <= target <= 109`","body":"var res = mutableListOf<MutableList<Int>>() if (nums.isEmpty()) return res nums.sort() val n = nums.size.toInt() var i = 0 var j = 0 while (i < n) { j = i+1 while (j < n) { var left = j+1 var right = n-1 while (left < right) { val cursum = nums[i]+nums[j]+nums[left]+nums[right] if (cursum == target) { res.add(mutableListOf(nums[i], nums[j], nums[left], nums[right])) while (left < right && nums[left] == nums[left+1]) ++left while (left < right && nums[right] == nums[right-1]) --right ++left --right } else if (cursum < target) { ++left } else { --right } } while (j+1 < n && nums[j] == nums[j+1]) ++j ++j } while (i+1 < n && nums[i] == nums[i+1]) ++i ++i } return res } }","difficulty":"medium"}
{"id":1309,"signature":"class Solution { fun freqAlphabets(s: String): String {","docstring":"Given a string `s` formed by digits (`'0'` - `'9'`) and `'#'` . We want to map `s` to English lowercase characters as follows:\nCharacters (`'a'` to `'i')` are represented by (`'1'` to `'9'`) respectively.\n\nCharacters (`'j'` to `'z')` are represented by (`'10#'` to `'26#'`) respectively. \nReturn the string formed after mapping.\n\nIt's guaranteed that a unique mapping will always exist.\n\n\nExample 1:\nInput: s = \"10#11#12\"\nOutput: \"jkab\"\nExplanation: \"j\" -> \"10#\" , \"k\" -> \"11#\" , \"a\" -> \"1\" , \"b\" -> \"2\".\n\n\nExample 2:\nInput: s = \"1326#\"\nOutput: \"acz\"\n\nExample 3:\nInput: s = \"25#\"\nOutput: \"y\"\n\nExample 4:\nInput: s = \"12345678910#11#12#13#14#15#16#17#18#19#20#21#22#23#24#25#26#\"\nOutput: \"abcdefghijklmnopqrstuvwxyz\"\n\nConstraints:\n`1 <= s.length <= 1000`\n`s[i]` only contains digits letters (`'0'`-`'9'`) and `'#'` letter.\n\n`s` will be valid string such that mapping is always possible.","body":"var res = \"\"; var i = s.length-1 while (i >= 0){ if (s[i] == '#') { res += (\"${s[i-2]}${s[i-1]}\".toInt()+'a'.toInt()-1).toChar() i -= 3 } else { res += (\"${s[i]}\".toInt()+'a'.toInt()-1).toChar() i-- } } return res.reversed() } }","difficulty":"easy"}
{"id":53,"signature":"class Solution { fun maxSubArray(nums: IntArray): Int {","docstring":"Given an integer array `nums`, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.\n\n\nExample 1:\nInput: nums = [-2,1,-3,4,-1,2,1,-5,4]\nOutput: 6\nExplanation: [4,-1,2,1] has the largest sum = 6.\n\n\nExample 2:\nInput: nums = [1]\nOutput: 1\n\nExample 3:\nInput: nums = [5,4,-1,7,8]\nOutput: 23\n\nConstraints:\n`1 <= nums.length <= 3 * 104`\n`-105 <= nums[i] <= 105`\nFollow up: If you have figured out the `O(n)` solution, try coding another solution using the divide and conquer approach, which is more subtle.","body":"var sum = 0 var maxa = -2147483647 nums.forEach { a -> if (sum < 0) { sum = a } else { sum += a } maxa = Math.max(sum, maxa) } return maxa } }","difficulty":"easy"}
{"id":1374,"signature":"class Solution { fun generateTheString(n: Int): String {","docstring":"Given an integer `n`, return a string with `n` characters such that each character in such string occurs an odd number of times.\n\nThe returned string must contain only lowercase English letters. If there are multiples valid strings, return any of them.  \n\nExample 1:\nInput: n = 4\nOutput: \"pppz\"\nExplanation: \"pppz\" is a valid string since the character 'p' occurs three times and the character 'z' occurs once. Note that there are many other valid strings such as \"ohhh\" and \"love\".\n\n\nExample 2:\nInput: n = 2\nOutput: \"xy\"\nExplanation: \"xy\" is a valid string since the characters 'x' and 'y' occur once. Note that there are many other valid strings such as \"ag\" and \"ur\".\n\n\nExample 3:\nInput: n = 7\nOutput: \"holasss\"\n\nConstraints:\n`1 <= n <= 500`","body":"var res = \"\" if (n%2 == 1) { for (i in 0 until n) res += \"a\" return res } else { for (i in 1 until n) res += \"a\" return res+\"b\" } } }","difficulty":"easy"}
{"id":96,"signature":"class Solution { fun numTrees(n: Int): Int {","docstring":"Given an integer `n`, return the number of structurally unique BST's (binary search trees) which has exactly `n` nodes of unique values from `1` to `n`.\n\n\nExample 1:\nInput: n = 3\nOutput: 5\n\nExample 2:\nInput: n = 1\nOutput: 1\n\nConstraints:\n`1 <= n <= 19`","body":"`  var x: Long = 1 var res: Long = 1 for (i in 1..n) { res = x*(4*i-2)\/(i+1) x = res } return res.toInt() } }","difficulty":"medium"}
{"id":25,"signature":"class Solution { fun reverseKGroup(head: ListNode?, k: Int): ListNode? {","docstring":"Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.\n\nk is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is.\n\nFollow up:\nCould you solve the problem in `O(1)` extra memory space?\nYou may not alter the values in the list's nodes, only nodes itself may be changed.\n\n\nExample 1:\nInput: head = [1,2,3,4,5], k = 2\nOutput: [2,1,4,3,5]\n\nExample 2:\nInput: head = [1,2,3,4,5], k = 3\nOutput: [3,2,1,4,5]\n\nExample 3:\nInput: head = [1,2,3,4,5], k = 1\nOutput: [1,2,3,4,5]\n\nExample 4:\nInput: head = [1], k = 1\nOutput: [1]\n\nConstraints:\nThe number of nodes in the list is in the range `sz`.\n\n`1 <= sz <= 5000`\n`0 <= Node.val <= 1000`\n`1 <= k <= sz`","body":"val dummy: ListNode? = ListNode(-1) dummy?.next = head var pre = dummy var cur = pre?.next var num = 0 while (cur != null) { ++num cur = cur?.next } while (num >= k) { cur = pre?.next for (i in 1 until k) { val t = cur?.next cur?.next = t?.next t?.next = pre?.next pre?.next = t } pre = cur num -= k } return dummy?.next } }","difficulty":"hard"}
{"id":1487,"signature":"class Solution { fun getFolderNames(names: Array<String>): Array<String> {","docstring":"Given an array of strings `names` of size `n`. You will create `n` folders in your file system such that, at the `ith` minute, you will create a folder with the name `names[i]`.\n\nSince two files cannot have the same name, if you enter a folder name which is previously used, the system will have a suffix addition to its name in the form of `(k)`, where, `k` is the smallest positive integer such that the obtained name remains unique.\n\nReturn an array of strings of length `n` where `ans[i]` is the actual name the system will assign to the `ith` folder when you create it.\n\n\nExample 1:\nInput: names = [\"pes\",\"fifa\",\"gta\",\"pes(2019)\"]\nOutput: [\"pes\",\"fifa\",\"gta\",\"pes(2019)\"]\nExplanation: Let's see how the file system creates folder names:\n\"pes\" --> not assigned before, remains \"pes\"\n\"fifa\" --> not assigned before, remains \"fifa\"\n\"gta\" --> not assigned before, remains \"gta\"\n\"pes(2019)\" --> not assigned before, remains \"pes(2019)\"\n\nExample 2:\nInput: names = [\"gta\",\"gta(1)\",\"gta\",\"avalon\"]\nOutput: [\"gta\",\"gta(1)\",\"gta(2)\",\"avalon\"]\nExplanation: Let's see how the file system creates folder names:\n\"gta\" --> not assigned before, remains \"gta\"\n\"gta(1)\" --> not assigned before, remains \"gta(1)\"\n\"gta\" --> the name is reserved, system adds (k), since \"gta(1)\" is also reserved, systems put k = 2. it becomes \"gta(2)\"\n\"avalon\" --> not assigned before, remains \"avalon\"\n\nExample 3:\nInput: names = [\"onepiece\",\"onepiece(1)\",\"onepiece(2)\",\"onepiece(3)\",\"onepiece\"]\nOutput: [\"onepiece\",\"onepiece(1)\",\"onepiece(2)\",\"onepiece(3)\",\"onepiece(4)\"]\nExplanation: When the last folder is created, the smallest positive valid k is 4, and it becomes \"onepiece(4)\".\n\n\nExample 4:\nInput: names = [\"wano\",\"wano\",\"wano\",\"wano\"]\nOutput: [\"wano\",\"wano(1)\",\"wano(2)\",\"wano(3)\"]\nExplanation: Just increase the value of k each time you create folder \"wano\".\n\n\nExample 5:\nInput: names = [\"kaido\",\"kaido(1)\",\"kaido\",\"kaido(1)\"]\nOutput: [\"kaido\",\"kaido(1)\",\"kaido(2)\",\"kaido(1)(1)\"]\nExplanation: Please note that system adds the suffix (k) to current name even it contained the same suffix before.\n\n\nConstraints:\n`1 <= names.length <= 5 * 10^4`\n`1 <= names[i].length <= 20`\n`names[i]` consists of lower case English letters, digits and\/or round brackets.","body":"val mm = mutableMapOf<String, Int>() var res = mutableListOf<String>() for (name in names) { if (name !in mm) { mm.put(name, 0) res.add(name) } else { while (true) { mm.put(name, mm.getOrDefault(name, 0)+1) val temp = \"${name}(${mm[name]})\" if (temp !in mm) { res.add(temp) mm[temp] = 0 break } } } } return res.toTypedArray() } }","difficulty":"medium"}
{"id":515,"signature":"class Solution { fun largestValues(root: TreeNode?): List<Int> {","docstring":"Given the `root` of a binary tree, return an array of the largest value in each row of the tree (0-indexed).\n\n\nExample 1:\nInput: root = [1,3,2,5,3,null,9]\nOutput: [1,3,9]\n\nExample 2:\nInput: root = [1,2,3]\nOutput: [1,3]\n\nExample 3:\nInput: root = [1]\nOutput: [1]\n\nExample 4:\nInput: root = [1,null,2]\nOutput: [1,2]\n\nExample 5:\nInput: root = []\nOutput: []\n\nConstraints:\nThe number of nodes in the tree will be in the range `[0, 104]`.\n\n`-231 <= Node.val <= 231 - 1`","body":"import java.util.LinkedList  if (root == null) return listOf<Int>() var q = LinkedList<TreeNode?>() var res = mutableListOf<Int>() q.offer(root) while (true) { var maxa = Int.MIN_VALUE val cnt = q.size if (cnt == 0) break for (i in 0 until cnt) { val top = q.poll() maxa = Math.max(maxa, top!!.`val`) if (top?.left != null) q.offer(top?.left) if (top?.right != null) q.offer(top?.right) } res.add(maxa) } return res } }","difficulty":"medium"}
{"id":120,"signature":"class Solution { fun minimumTotal(triangle: List<List<Int>>): Int {","docstring":"Given a `triangle` array, return the minimum path sum from top to bottom.\n\nFor each step, you may move to an adjacent number of the row below. More formally, if you are on index `i` on the current row, you may move to either index `i` or index `i + 1` on the next row.\n\n\nExample 1:\nInput: triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]\nOutput: 11\nExplanation: The triangle looks like:\n   2\n  3 4\n 6 5 7\n4 1 8 3\nThe minimum path sum from top to bottom is 2 + 3 + 5 + 1 = 11 (underlined above).\n\n\nExample 2:\nInput: triangle = [[-10]]\nOutput: -10\n\nConstraints:\n`1 <= triangle.length <= 200`\n`triangle[0].length == 1`\n`triangle[i].length == triangle[i - 1].length + 1`\n`-104 <= triangle[i][j] <= 104`\nFollow up: Could you do this using only `O(n)` extra space, where `n` is the total number of rows in the triangle?","body":"var n = triangle.size if (n == 0) return 0 var dp = Array(n+1) { IntArray(n+1, {0x3f3f3f3f}) } dp[0][0] = triangle[0][0] for (i in 1 until n) for (j in 0 .. i) if (j == 0) dp[i][j] = dp[i-1][j]+triangle[i][j] else dp[i][j] = Math.min(dp[i-1][j], dp[i-1][j-1])+triangle[i][j] var maxa = 0x3f3f3f3f for (i in 0 until n) maxa = Math.min(maxa, dp[n-1][i]) return maxa } }","difficulty":"medium"}
{"id":204,"signature":"class Solution { fun countPrimes(n: Int): Int {","docstring":"Count the number of prime numbers less than a non-negative number, `n`.\n\n\nExample 1:\nInput: n = 10\nOutput: 4\nExplanation: There are 4 prime numbers less than 10, they are 2, 3, 5, 7.\n\n\nExample 2:\nInput: n = 0\nOutput: 0\n\nExample 3:\nInput: n = 1\nOutput: 0\n\nConstraints:\n`0 <= n <= 5 * 106`","body":"var isp = BooleanArray(n+1) { true } var p = mutableListOf<Int>() for (i in 2 until n) { if (isp[i]) p.add(i) for (j in 0 until p.size) { if (i*p[j] >= n) break isp[i*p[j]] = false if (i%p[j] == 0) break } } return p.size.toInt() } }","difficulty":"easy"}
{"id":127,"signature":"class Solution { fun ladderLength(beginWord: String, endWord: String, wordList: List<String>): Int {","docstring":"A transformation sequence from word `beginWord` to word `endWord` using a dictionary `wordList` is a sequence of words `beginWord -> s1 -> s2 -> ... -> sk` such that:\nEvery adjacent pair of words differs by a single letter.\n\nEvery `si` for `1 <= i <= k` is in `wordList`. Note that `beginWord` does not need to be in `wordList`.\n\n`sk == endWord`\nGiven two words, `beginWord` and `endWord`, and a dictionary `wordList`, return the number of words in the shortest transformation sequence from `beginWord` to `endWord`, or `0` if no such sequence exists.\n\n\nExample 1:\nInput: beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\nOutput: 5\nExplanation: One shortest transformation sequence is \"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> cog\", which is 5 words long.\n\n\nExample 2:\nInput: beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\nOutput: 0\nExplanation: The endWord \"cog\" is not in wordList, therefore there is no valid transformation sequence.\n\n\nConstraints:\n`1 <= beginWord.length <= 10`\n`endWord.length == beginWord.length`\n`1 <= wordList.length <= 5000`\n`wordList[i].length == beginWord.length`\n`beginWord`, `endWord`, and `wordList[i]` consist of lowercase English letters.\n\n`beginWord != endWord`\nAll the words in `wordList` are unique.","body":"import java.util.LinkedList class Solution { data class Node( var str: String = \"\", var step: Int = 0 ) fun ladderLength(beginWord: String, endWord: String, wordList: List<String>): Int { var q = LinkedList<Node>() var vis = mutableMapOf<String, Boolean>() q.offer(Node(beginWord, 1)) vis[beginWord] = true while (!q.isEmpty()) { val top = q.poll() if (top.str == endWord) { return top.step } for (i in wordList) { if (vis[i] ?: false) continue var cnt = 0 for (j in 0 until beginWord.length) if (top.str[j] != i[j]) cnt++ if (cnt <= 1) { vis[i] = true q.offer(Node(i, top.step+1)) } } } return 0 } }","difficulty":"medium"}
{"id":139,"signature":"class Solution { fun wordBreak(s: String, wordDict: List<String>): Boolean {","docstring":"Given a string `s` and a dictionary of strings `wordDict`, return `true` if `s` can be segmented into a space-separated sequence of one or more dictionary words.\n\nNote that the same word in the dictionary may be reused multiple times in the segmentation.\n\n\nExample 1:\nInput: s = \"leetcode\", wordDict = [\"leet\",\"code\"]\nOutput: true\nExplanation: Return true because \"leetcode\" can be segmented as \"leet code\".\n\n\nExample 2:\nInput: s = \"applepenapple\", wordDict = [\"apple\",\"pen\"]\nOutput: true\nExplanation: Return true because \"applepenapple\" can be segmented as \"apple pen apple\".\n\nNote that you are allowed to reuse a dictionary word.\n\n\nExample 3:\nInput: s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\nOutput: false\n\nConstraints:\n`1 <= s.length <= 300`\n`1 <= wordDict.length <= 1000`\n`1 <= wordDict[i].length <= 20`\n`s` and `wordDict[i]` consist of only lowercase English letters.\n\nAll the strings of `wordDict` are unique.","body":"val n = s.length var dp = BooleanArray(n+1) { false } dp[0] = true for (i in 1 .. n) { for(j in 0 .. i-1) { if (dp[j]) { val str = s.substring(j, i) if (str in wordDict) { dp[i] = true break } } } } return dp[n] } }","difficulty":"medium"}
{"id":7,"signature":"class Solution { fun reverse(x: Int): Int {","docstring":"Given a signed 32-bit integer `x`, return `x` with its digits reversed. If reversing `x` causes the value to go outside the signed 32-bit integer range `[-231, 231 - 1]`, then return `0`.\n\nAssume the environment does not allow you to store 64-bit integers (signed or unsigned).\n\n\nExample 1:\nInput: x = 123\nOutput: 321\n\nExample 2:\nInput: x = -123\nOutput: -321\n\nExample 3:\nInput: x = 120\nOutput: 21\n\nExample 4:\nInput: x = 0\nOutput: 0\n\nConstraints:\n`-231 <= x <= 231 - 1`","body":"var res = 0 var n = x while (n != 0) { if (Math.abs(res) > Int.MAX_VALUE\/10) return 0 res = res*10 + n % 10 n \/= 10 } return res } }","difficulty":"easy"}
{"id":50,"signature":"class Solution { fun myPow(x: Double, n: Int): Double {","docstring":"Implement pow(x, n), which calculates `x` raised to the power `n` (i.e., `xn`).\n\n\nExample 1:\nInput: x = 2.00000, n = 10\nOutput: 1024.00000\n\nExample 2:\nInput: x = 2.10000, n = 3\nOutput: 9.26100\n\nExample 3:\nInput: x = 2.00000, n = -2\nOutput: 0.25000\nExplanation: 2-2 = 1\/22 = 1\/4 = 0.25\n\nConstraints:\n`-100.0 < x < 100.0`\n`-231 <= n <= 231-1`\n`-104 <= xn <= 104`","body":"var ans = 1.0 var a = x var b = Math.abs(n.toLong()) while (b > 0) { if (b%2 == 1L) ans = ans*a a *= a b = b.shr(1) } if (n < 0) return 1\/ans else return ans } }","difficulty":"medium"}
{"id":15,"signature":"class Solution { fun threeSum(nums: IntArray): List<List<Int>> {","docstring":"Given an integer array nums, return all the triplets `[nums[i], nums[j], nums[k]]` such that `i != j`, `i != k`, and `j != k`, and `nums[i] + nums[j] + nums[k] == 0`.\n\nNotice that the solution set must not contain duplicate triplets.\n\n\nExample 1:\nInput: nums = [-1,0,1,2,-1,-4]\nOutput: [[-1,-1,2],[-1,0,1]]\n\nExample 2:\nInput: nums = []\nOutput: []\n\nExample 3:\nInput: nums = [0]\nOutput: []\n\nConstraints:\n`0 <= nums.length <= 3000`\n`-105 <= nums[i] <= 105`","body":"nums.sort() val res = mutableListOf<List<Int>>() var x: Int var y: Int for (i in 0 until nums.size-2) { if (nums[i] > 0) break if (i > 0 && nums[i] == nums[i-1]) continue x = i+1 y = nums.size-1 while (x < y) { val temp = nums[x]+nums[y]+nums[i] if (temp == 0) { res.add(listOf(nums[i], nums[x], nums[y])) while (x < y && nums[x] == nums[x+1]) x++ while (x < y && nums[y] == nums[y-1]) y-- x++ y-- } else if (temp > 0) { y-- } else { x++ } } } return res } }","difficulty":"medium"}
{"id":32,"signature":"class Solution { fun longestValidParentheses(s: String): Int {","docstring":"Given a string containing just the characters `'('` and `')'`, find the length of the longest valid (well-formed) parentheses substring.\n\n\nExample 1:\nInput: s = \"(()\"\nOutput: 2\nExplanation: The longest valid parentheses substring is \"()\".\n\n\nExample 2:\nInput: s = \")()())\"\nOutput: 4\nExplanation: The longest valid parentheses substring is \"()()\".\n\n\nExample 3:\nInput: s = \"\"\nOutput: 0\n\nConstraints:\n`0 <= s.length <= 3 * 104`\n`s[i]` is `'('`, or `')'`.","body":"var dp = IntArray(100000, {0}) var res = 0 for (i in 2 .. s.length) { if (s[i-1] == ')') { if (i-dp[i-1]-2 >= 0 && s[i-dp[i-1]-2] == '(') { dp[i] = dp[i-1]+2 dp[i] += dp[i-dp[i]] } } if (res < dp[i]) res = dp[i] } return res } }","difficulty":"hard"}
