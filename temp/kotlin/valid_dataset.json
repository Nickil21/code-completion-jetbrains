{"id":1551,"signature":"class Solution { fun minOperations(n: Int): Int {","docstring":"You have an array `arr` of length `n` where `arr[i] = (2 * i) + 1` for all valid values of `i` (i.e. `0 <= i < n`).\n\nIn one operation, you can select two indices `x` and `y` where `0 <= x, y < n` and subtract `1` from `arr[x]` and add `1` to `arr[y]` (i.e. perform `arr[x] -=1 `and `arr[y] += 1`). The goal is to make all the elements of the array equal. It is guaranteed that all the elements of the array can be made equal using some operations.\n\nGiven an integer `n`, the length of the array. Return the minimum number of operations needed to make all the elements of arr equal.\n\n\nExample 1:\nInput: n = 3\nOutput: 2\nExplanation: arr = [1, 3, 5]\nFirst operation choose x = 2 and y = 0, this leads arr to be [2, 3, 4]\nIn the second operation choose x = 2 and y = 0 again, thus arr = [3, 3, 3].\n\n\nExample 2:\nInput: n = 6\nOutput: 9\n\nConstraints:\n`1 <= n <= 10^4`","body":"var ans = 0 for (i in 0 until n\/2) { ans += n-2*i-1 } return ans } }","difficulty":"medium"}
{"id":169,"signature":"class Solution { fun majorityElement(nums: IntArray): Int {","docstring":"Given an array `nums` of size `n`, return the majority element.\n\nThe majority element is the element that appears more than `\u230an \/ 2\u230b` times. You may assume that the majority element always exists in the array.\n\n\nExample 1:\nInput: nums = [3,2,3]\nOutput: 3\n\nExample 2:\nInput: nums = [2,2,1,1,1,2,2]\nOutput: 2\n\nConstraints:\n`n == nums.length`\n`1 <= n <= 5 * 104`\n`-231 <= nums[i] <= 231 - 1`\nFollow-up: Could you solve the problem in linear time and in `O(1)` space?","body":"val n = nums.size\/2 val mm = mutableMapOf<Int, Int>() nums.forEach { mm.put(it, mm.getOrDefault(it, 0)+1) if (mm.getOrDefault(it, 0) > n) return it } return -1 } }","difficulty":"easy"}
{"id":22,"signature":"class Solution { fun generateParenthesis(n: Int): List<String> {","docstring":"Given `n` pairs of parentheses, write a function to generate all combinations of well-formed parentheses.\n\n\nExample 1:\nInput: n = 3\nOutput: [\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\n\nExample 2:\nInput: n = 1\nOutput: [\"()\"]\n\nConstraints:\n`1 <= n <= 8`","body":"var res = mutableListOf<String>() dfs(n, n, \"\", res) return res } private fun dfs(left: Int, right: Int, str: String, res: MutableList<String>) { if (left > right) return ; if (left == 0 && right == 0) { res.add(str); } else { if (left > 0) dfs(left-1, right, str+'(', res); if (right > 0) dfs(left, right-1, str+')', res); } } }","difficulty":"medium"}
{"id":91,"signature":"class Solution { fun numDecodings(s: String): Int {","docstring":"A message containing letters from `A-Z` can be encoded into numbers using the following mapping:\n'A' -> \"1\"\n'B' -> \"2\"\n...\n\n'Z' -> \"26\"\nTo decode an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, `\"11106\"` can be mapped into:\n`\"AAJF\"` with the grouping `(1 1 10 6)`\n`\"KJF\"` with the grouping `(11 10 6)`\nNote that the grouping `(1 11 06)` is invalid because `\"06\"` cannot be mapped into `'F'` since `\"6\"` is different from `\"06\"`.\n\nGiven a string `s` containing only digits, return the number of ways to decode it.\n\nThe answer is guaranteed to fit in a 32-bit integer.\n\n\nExample 1:\nInput: s = \"12\"\nOutput: 2\nExplanation: \"12\" could be decoded as \"AB\" (1 2) or \"L\" (12).\n\n\nExample 2:\nInput: s = \"226\"\nOutput: 3\nExplanation: \"226\" could be decoded as \"BZ\" (2 26), \"VF\" (22 6), or \"BBF\" (2 2 6).\n\n\nExample 3:\nInput: s = \"0\"\nOutput: 0\nExplanation: There is no character that is mapped to a number starting with 0.\n\nThe only valid mappings with 0 are 'J' -> \"10\" and 'T' -> \"20\", neither of which start with 0.\n\nHence, there are no valid ways to decode this since all digits need to be mapped.\n\n\nExample 4:\nInput: s = \"06\"\nOutput: 0\nExplanation: \"06\" cannot be mapped to \"F\" because of the leading zero (\"6\" is different from \"06\").\n\n\nConstraints:\n`1 <= s.length <= 100`\n`s` contains only digits and may contain leading zero(s).","body":"val n = s.length var dp = IntArray(n+1) dp[0] = 1 for (i in 1 .. n) { if (s[i-1] != '0') dp[i] = dp[i-1] if (i != 1 && (s[i-2]-'0')*10+(s[i-1]-'0') < 27 && (s[i-2]-'0')*10+(s[i-1]-'0') > 9) dp[i] += dp[i-2] } return dp[n] } }","difficulty":"medium"}
{"id":85,"signature":"class Solution { fun maximalRectangle(matrix: Array<CharArray>): Int {","docstring":"Given a `rows x cols` binary `matrix` filled with `0`'s and `1`'s, find the largest rectangle containing only `1`'s and return its area.\n\n\nExample 1:\nInput: matrix = [[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]]\nOutput: 6\nExplanation: The maximal rectangle is shown in the above picture.\n\n\nExample 2:\nInput: matrix = []\nOutput: 0\n\nExample 3:\nInput: matrix = [[\"0\"]]\nOutput: 0\n\nExample 4:\nInput: matrix = [[\"1\"]]\nOutput: 1\n\nExample 5:\nInput: matrix = [[\"0\",\"0\"]]\nOutput: 0\n\nConstraints:\n`rows == matrix.length`\n`cols == matrix[i].length`\n`0 <= row, cols <= 200`\n`matrix[i][j]` is `'0'` or `'1'`.","body":"if (matrix.size == 0) return 0 val n = matrix.size val m = matrix[0].size var dp = Array(n+5){IntArray(m+5)} for (i in 0 until n) for (j in 0 until m) dp[i+1][j+1] = matrix[i][j]-'0' var col = Array(n+5){IntArray(m+5)} for (i in 1 .. m) { for (j in 1 .. n) { if (dp[j][i] == 1) col[j][i] = col[j-1][i]+dp[j][i] } } var maxa = 0 for (i in 1 .. n) { for (j in i .. n) { var r = IntArray(m+1) for (k in 1 .. m) r[k] = col[j][k]-col[i-1][k] var temp = 0 for (k in 1 .. m) { if (r[k] == r[k-1]) { temp += r[k] } else { temp = r[k] } maxa = Math.max(maxa, temp) } } } return maxa } }","difficulty":"hard"}
{"id":279,"signature":"class Solution { fun numSquares(n: Int): Int {","docstring":"Given an integer `n`, return the least number of perfect square numbers that sum to `n`.\n\nA perfect square is an integer that is the square of an integer; in other words, it is the product of some integer with itself. For example, `1`, `4`, `9`, and `16` are perfect squares while `3` and `11` are not.\n\n\nExample 1:\nInput: n = 12\nOutput: 3\nExplanation: 12 = 4 + 4 + 4.\n\n\nExample 2:\nInput: n = 13\nOutput: 2\nExplanation: 13 = 4 + 9.\n\n\nConstraints:\n`1 <= n <= 104`","body":"var mN = n while (mN % 4 == 0) mN \/= 4 if (mN % 8 == 7) return 4 var i = 0 while (i*i <= n) { val temp = Math.sqrt(n-i*i*1.0).toInt() if (n == temp*temp+i*i) { return if (temp == 0 || i == 0) 1 else 2 } i++ } return 3 } } fun main(args: Array<String>) { val test = Solution() println(test.numSquares(29825)) }","difficulty":"medium"}
{"id":869,"signature":"class Solution { fun reorderedPowerOf2(N: Int): Boolean {","docstring":"You are given an integer `n`. We reorder the digits in any order (including the original order) such that the leading digit is not zero.\n\nReturn `true` if and only if we can do this so that the resulting number is a power of two.\n\n\nExample 1:\nInput: n = 1\nOutput: true\n\nExample 2:\nInput: n = 10\nOutput: false\n\nExample 3:\nInput: n = 16\nOutput: true\n\nExample 4:\nInput: n = 24\nOutput: false\n\nExample 5:\nInput: n = 46\nOutput: true\n\nConstraints:\n`1 <= n <= 109`","body":"class Solution { private var cnt = IntArray(10) fun reorderedPowerOf2(N: Int): Boolean { val str = N.toString() for (i in str) cnt[i - '0']++ for (i in 0 until 31) { val temp = (1.shl(i)).toString() if (temp.length == str.length && ok(temp)) { return true } } return false } private fun ok(str: String): Boolean { var vis = IntArray(10) for (i in str) vis[i - '0']++ for (i in 0 until 10) if (vis[i] != cnt[i]) return false return true } }","difficulty":"medium"}
{"id":264,"signature":"class Solution { fun nthUglyNumber(n: Int): Int {","docstring":"Given an integer `n`, return the `nth` ugly number.\n\nUgly number is a positive number whose prime factors only include `2`, `3`, and\/or `5`.\n\n\nExample 1:\nInput: n = 10\nOutput: 12\nExplanation: [1, 2, 3, 4, 5, 6, 8, 9, 10, 12] is the sequence of the first 10 ugly numbers.\n\n\nExample 2:\nInput: n = 1\nOutput: 1\nExplanation: 1 is typically treated as an ugly number.\n\n\nConstraints:\n`1 <= n <= 1690`","body":"var ug = IntArray(n+1) ug[0] = 1 var id2 = 0 var id3 = 0 var id5 = 0 var cnt = 1 while (cnt < n) { val temp = Math.min(ug[id2]*2, Math.min(ug[id3]*3, ug[id5]*5)) if (temp == ug[id2]*2) id2++ if (temp == ug[id3]*3) id3++ if (temp == ug[id5]*5) id5++ ug[cnt++] = temp } return ug[n-1] } }","difficulty":"medium"}
{"id":1404,"signature":"class Solution { fun numSteps(s: String): Int {","docstring":"Given a number `s` in their binary representation. Return the number of steps to reduce it to 1 under the following rules:\nIf the current number is even, you have to divide it by 2.\n\nIf the current number is odd, you have to add 1 to it.\n\nIt's guaranteed that you can always reach to one for all testcases.\n\n\nExample 1:\nInput: s = \"1101\"\nOutput: 6\nExplanation: \"1101\" corressponds to number 13 in their decimal representation.\n\nStep 1) 13 is odd, add 1 and obtain 14. \nStep 2) 14 is even, divide by 2 and obtain 7.\n\nStep 3) 7 is odd, add 1 and obtain 8.\n\nStep 4) 8 is even, divide by 2 and obtain 4.  \nStep 5) 4 is even, divide by 2 and obtain 2. \nStep 6) 2 is even, divide by 2 and obtain 1.  \n\nExample 2:\nInput: s = \"10\"\nOutput: 1\nExplanation: \"10\" corressponds to number 2 in their decimal representation.\n\nStep 1) 2 is even, divide by 2 and obtain 1.  \n\nExample 3:\nInput: s = \"1\"\nOutput: 0\n\nConstraints:\n`1 <= s.length <= 500`\n`s` consists of characters '0' or '1'\n`s[0] == '1'`","body":"var res = 0 var cnt = 0 for (i in s.length-1 downTo 1) { res++ if (s[i]-'0'+cnt == 1) { res++ cnt = 1 } } return res+cnt } }","difficulty":"medium"}
{"id":72,"signature":"class Solution { fun minDistance(word1: String, word2: String): Int {","docstring":"Given two strings `word1` and `word2`, return the minimum number of operations required to convert `word1` to `word2`.\n\nYou have the following three operations permitted on a word:\nInsert a character\nDelete a character\nReplace a character\n\nExample 1:\nInput: word1 = \"horse\", word2 = \"ros\"\nOutput: 3\nExplanation: \nhorse -> rorse (replace 'h' with 'r')\nrorse -> rose (remove 'r')\nrose -> ros (remove 'e')\n\nExample 2:\nInput: word1 = \"intention\", word2 = \"execution\"\nOutput: 5\nExplanation: \nintention -> inention (remove 't')\ninention -> enention (replace 'i' with 'e')\nenention -> exention (replace 'n' with 'x')\nexention -> exection (replace 'n' with 'c')\nexection -> execution (insert 'u')\n\nConstraints:\n`0 <= word1.length, word2.length <= 500`\n`word1` and `word2` consist of lowercase English letters.","body":"if (word1 == \"\") return word2.length if (word2 == \"\") return word1.length val n = word1.length val m = word2.length var dp = Array(n+1){IntArray(m+1)} for (i in 0 .. n) dp[i][0] = i for (i in 0 .. m) dp[0][i] = i for (i in 1 .. n) { for (j in 1 .. m) { if (word1[i-1] == word2[j-1]) { dp[i][j] = dp[i-1][j-1] } else { dp[i][j] = Math.min(dp[i][j-1], Math.min(dp[i-1][j], dp[i-1][j-1]))+1 } } } return dp[n][m] } }","difficulty":"hard"}
{"id":162,"signature":"class Solution { fun findPeakElement(nums: IntArray): Int {","docstring":"A peak element is an element that is strictly greater than its neighbors.\n\nGiven an integer array `nums`, find a peak element, and return its index. If the array contains multiple peaks, return the index to any of the peaks.\n\nYou may imagine that `nums[-1] = nums[n] = -\u221e`.\n\n\nExample 1:\nInput: nums = [1,2,3,1]\nOutput: 2\nExplanation: 3 is a peak element and your function should return the index number 2.\n\n\nExample 2:\nInput: nums = [1,2,1,3,5,6,4]\nOutput: 5\nExplanation: Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6.\n\n\nConstraints:\n`1 <= nums.length <= 1000`\n`-231 <= nums[i] <= 231 - 1`\n`nums[i] != nums[i + 1]` for all valid `i`.\n\nFollow up: Could you implement a solution with logarithmic complexity?","body":"var left = 0 var right = nums.size - 1 while (left < right) { val mid = left + (right - left) \/ 2 if (nums[mid] < nums[mid+1]) left = mid + 1 else right = mid } return right } }","difficulty":"medium"}
{"id":140,"signature":"class Solution { fun wordBreak(s: String, wordDict: List<String>): List<String> {","docstring":"Given a string `s` and a dictionary of strings `wordDict`, add spaces in `s` to construct a sentence where each word is a valid dictionary word. Return all such possible sentences in any order.\n\nNote that the same word in the dictionary may be reused multiple times in the segmentation.\n\n\nExample 1:\nInput: s = \"catsanddog\", wordDict = [\"cat\",\"cats\",\"and\",\"sand\",\"dog\"]\nOutput: [\"cats and dog\",\"cat sand dog\"]\n\nExample 2:\nInput: s = \"pineapplepenapple\", wordDict = [\"apple\",\"pen\",\"applepen\",\"pine\",\"pineapple\"]\nOutput: [\"pine apple pen apple\",\"pineapple pen apple\",\"pine applepen apple\"]\nExplanation: Note that you are allowed to reuse a dictionary word.\n\n\nExample 3:\nInput: s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\nOutput: []\n\nConstraints:\n`1 <= s.length <= 20`\n`1 <= wordDict.length <= 1000`\n`1 <= wordDict[i].length <= 10`\n`s` and `wordDict[i]` consist of only lowercase English letters.\n\nAll the strings of `wordDict` are unique.","body":"class Solution { var dp = mutableMapOf<String, List<String>>() fun wordBreak(s: String, wordDict: List<String>): List<String> { if (dp.containsKey(s)) return dp[s]!! var a = mutableListOf<String>() for (i in wordDict.indices) { val temp = wordDict[i] if (s.length >= temp.length && s.substring(0, temp.length) == temp) { if (temp.length == s.length) { a.add(temp) } else { val subR = wordBreak(s.substring(temp.length), wordDict) for (j in subR.indices) { a.add(\"${temp} ${subR[j]}\") } } } } dp[s] = a return a } }","difficulty":"hard"}
{"id":5,"signature":"class Solution { fun longestPalindrome(s: String): String {","docstring":"Given a string `s`, return the longest palindromic substring in `s`.\n\n\nExample 1:\nInput: s = \"babad\"\nOutput: \"bab\"\nNote: \"aba\" is also a valid answer.\n\n\nExample 2:\nInput: s = \"cbbd\"\nOutput: \"bb\"\n\nExample 3:\nInput: s = \"a\"\nOutput: \"a\"\n\nExample 4:\nInput: s = \"ac\"\nOutput: \"a\"\n\nConstraints:\n`1 <= s.length <= 1000`\n`s` consist of only digits and English letters (lower-case and\/or upper-case),","body":"var str = \"$#\" for (i in 0 until s.length) { str += s[i] str += \"#\" } str += \"^\" var RL = IntArray(str.length, {0}) var maxr = 0 var pos = 0 var maxlen = 0 var id = 0 for (i in 1 until str.length-1) { RL[i] = if (i < maxr) Math.min(RL[2*pos-i], maxr-i) else 1 while (str[i-RL[i]] == str[i+RL[i]]) RL[i]++ if (RL[i]+i > maxr) { maxr = RL[i]+i pos = i } } for (i in 1 until str.length-1) { if (RL[i] > maxlen) { maxlen = RL[i] id = i } } val start = (id-maxlen)\/2 val end = start+maxlen-1 return s.substring(start, end) } }","difficulty":"medium"}
{"id":310,"signature":"class Solution { fun findMinHeightTrees(n: Int, edges: Array<IntArray>): List<Int> {","docstring":"A tree is an undirected graph in which any two vertices are connected by exactly one path. In other words, any connected graph without simple cycles is a tree.\n\nGiven a tree of `n` nodes labelled from `0` to `n - 1`, and an array of `n - 1` `edges` where `edges[i] = [ai, bi]` indicates that there is an undirected edge between the two nodes `ai` and `bi` in the tree, you can choose any node of the tree as the root. When you select a node `x` as the root, the result tree has height `h`. Among all possible rooted trees, those with minimum height (i.e. `min(h)`)  are called minimum height trees (MHTs).\n\nReturn a list of all MHTs' root labels. You can return the answer in any order.\n\nThe height of a rooted tree is the number of edges on the longest downward path between the root and a leaf.\n\n\nExample 1:\nInput: n = 4, edges = [[1,0],[1,2],[1,3]]\nOutput: [1]\nExplanation: As shown, the height of the tree is 1 when the root is the node with label 1 which is the only MHT.\n\n\nExample 2:\nInput: n = 6, edges = [[3,0],[3,1],[3,2],[3,4],[5,4]]\nOutput: [3,4]\n\nExample 3:\nInput: n = 1, edges = []\nOutput: [0]\n\nExample 4:\nInput: n = 2, edges = [[0,1]]\nOutput: [0,1]\n\nConstraints:\n`1 <= n <= 2 * 104`\n`edges.length == n - 1`\n`0 <= ai, bi < n`\n`ai != bi`\nAll the pairs `(ai, bi)` are distinct.\n\nThe given input is guaranteed to be a tree and there will be no repeated edges.","body":"import java.util.LinkedList  if (n == 1) return listOf(0) var q = LinkedList<Int>() var e = Array<MutableList<Int>>(n+1) { mutableListOf<Int>() } var vis = BooleanArray(n+1) var ind = IntArray(n+1) for (edge in edges) { ind[edge[0]]++ ind[edge[1]]++ e[edge[0]].add(edge[1]) e[edge[1]].add(edge[0]) } var cnt = n for (i in 0 until n) { if (ind[i] == 1) { vis[i] = true q.offer(i) } } while (cnt > 2) { val sz = q.size cnt -= sz for (i in 0 until sz) { val top = q.poll() for (j in e[top]) { if (!vis[j]) { ind[j]-- if (ind[j] == 1) q.offer(j) } } } } return q.toList() } }","difficulty":"medium"}
{"id":17,"signature":"class Solution { fun letterCombinations(digits: String): List<String> {","docstring":"Given a string containing digits from `2-9` inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.\n\nA mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.\n\n\nExample 1:\nInput: digits = \"23\"\nOutput: [\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]\n\nExample 2:\nInput: digits = \"\"\nOutput: []\n\nExample 3:\nInput: digits = \"2\"\nOutput: [\"a\",\"b\",\"c\"]\n\nConstraints:\n`0 <= digits.length <= 4`\n`digits[i]` is a digit in the range `['2', '9']`.","body":"import java.util.LinkedList class Solution { private val mm = mapOf('2' to \"abc\", '3' to \"def\", '4' to \"ghi\", '5' to \"jkl\", '6' to \"mno\", '7' to \"pqrs\", '8' to \"tuv\", '9' to \"wxyz\") fun letterCombinations(digits: String): List<String> { var res = mutableListOf<String>() if (digits.length == 0) return res var word: String = \"\" fun dfs(cur: Int) { if (cur >= digits.length) { res.add(word) return ; } for (i in mm[digits[cur]]!!) { word += i dfs(cur+1) word = word.substring(0, word.length-1) } } dfs(0) return res } }","difficulty":"medium"}
{"id":31,"signature":"class Solution { fun nextPermutation(nums: IntArray): Unit {","docstring":"Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.\n\nIf such an arrangement is not possible, it must rearrange it as the lowest possible order (i.e., sorted in ascending order).\n\nThe replacement must be in place and use only constant extra memory.\n\n\nExample 1:\nInput: nums = [1,2,3]\nOutput: [1,3,2]\n\nExample 2:\nInput: nums = [3,2,1]\nOutput: [1,2,3]\n\nExample 3:\nInput: nums = [1,1,5]\nOutput: [1,5,1]\n\nExample 4:\nInput: nums = [1]\nOutput: [1]\n\nConstraints:\n`1 <= nums.length <= 100`\n`0 <= nums[i] <= 100`","body":"val n = nums.size var flag = -1 for (i in n-1 downTo 1) { if (nums[i] > nums[i-1]) { flag = i-1 break } } if (flag == -1) { nums.sort(0, n) } else { var mina = Int.MAX_VALUE var st = -1 for (i in flag+1 until n) { if (nums[i] <= nums[flag]) continue if (nums[i] < mina) { mina = nums[i] st = i } } val temp = nums[flag] nums[flag] = nums[st] nums[st] = temp nums.sort(flag+1, n) } } }","difficulty":"medium"}
{"id":12,"signature":"class Solution { fun intToRoman(num: Int): String {","docstring":"Roman numerals are represented by seven different symbols: `I`, `V`, `X`, `L`, `C`, `D` and `M`.\n\nSymbol       Value\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000\nFor example, `2` is written as `II` in Roman numeral, just two one's added together. `12` is written as `XII`, which is simply `X + II`. The number `27` is written as `XXVII`, which is `XX + V + II`.\n\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not `IIII`. Instead, the number four is written as `IV`. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as `IX`. There are six instances where subtraction is used:\n`I` can be placed before `V` (5) and `X` (10) to make 4 and 9. \n`X` can be placed before `L` (50) and `C` (100) to make 40 and 90. \n`C` can be placed before `D` (500) and `M` (1000) to make 400 and 900.\n\nGiven an integer, convert it to a roman numeral.\n\n\nExample 1:\nInput: num = 3\nOutput: \"III\"\n\nExample 2:\nInput: num = 4\nOutput: \"IV\"\n\nExample 3:\nInput: num = 9\nOutput: \"IX\"\n\nExample 4:\nInput: num = 58\nOutput: \"LVIII\"\nExplanation: L = 50, V = 5, III = 3.\n\n\nExample 5:\nInput: num = 1994\nOutput: \"MCMXCIV\"\nExplanation: M = 1000, CM = 900, XC = 90 and IV = 4.\n\n\nConstraints:\n`1 <= num <= 3999`","body":"class Solution { private val m_k = listOf(1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1) private val m_v = listOf(\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\") fun intToRoman(num: Int): String { var str = \"\" var n = num for (i in m_k.indices) { while (n >= m_k[i]) { n -= m_k[i] str += m_v[i] } } return str } }","difficulty":"medium"}
{"id":1382,"signature":"class Solution { fun balanceBST(root: TreeNode?): TreeNode? {","docstring":"Given a binary search tree, return a balanced binary search tree with the same node values.\n\nA binary search tree is balanced if and only if the depth of the two subtrees of every node never differ by more than 1.\n\nIf there is more than one answer, return any of them.\n\n\nExample 1:\nInput: root = [1,null,2,null,3,null,4,null,null]\nOutput: [2,1,3,null,null,null,4]\nExplanation: This is not the only correct answer, [3,1,4,null,2,null,null] is also correct.\n\n\nConstraints:\nThe number of nodes in the tree is between `1` and `10^4`.\n\nThe tree nodes will have distinct values between `1` and `10^5`.","body":"class Solution { private var arr = IntArray(10005) private var cnt = 0 fun balanceBST(root: TreeNode?): TreeNode? { cnt = 0 var head = root dfs(head) return sortedArrayToBST(cnt) } fun dfs(root: TreeNode?) { if (root?.left != null) dfs(root?.left) arr[cnt++] = root!!.`val` if (root?.right != null) dfs(root?.right) } fun sortedArrayToBST(start: Int, end: Int): TreeNode? { if (start > end) return null val mid = start + (end - start) \/ 2 var root: TreeNode? = TreeNode(arr[mid]) root?.left = sortedArrayToBST(start, mid-1) root?.right = sortedArrayToBST(mid+1, end) return root } fun sortedArrayToBST(n: Int): TreeNode? { return sortedArrayToBST(0, n-1) } }","difficulty":"medium"}
{"id":207,"signature":"class Solution { fun canFinish(numCourses: Int, prerequisites: Array<IntArray>): Boolean {","docstring":"There are a total of `numCourses` courses you have to take, labeled from `0` to `numCourses - 1`. You are given an array `prerequisites` where `prerequisites[i] = [ai, bi]` indicates that you must take course `bi` first if you want to take course `ai`.\n\nFor example, the pair `[0, 1]`, indicates that to take course `0` you have to first take course `1`.\n\nReturn `true` if you can finish all courses. Otherwise, return `false`.\n\n\nExample 1:\nInput: numCourses = 2, prerequisites = [[1,0]]\nOutput: true\nExplanation: There are a total of 2 courses to take. \nTo take course 1 you should have finished course 0. So it is possible.\n\n\nExample 2:\nInput: numCourses = 2, prerequisites = [[1,0],[0,1]]\nOutput: false\nExplanation: There are a total of 2 courses to take. \nTo take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.\n\n\nConstraints:\n`1 <= numCourses <= 105`\n`0 <= prerequisites.length <= 5000`\n`prerequisites[i].length == 2`\n`0 <= ai, bi < numCourses`\nAll the pairs prerequisites[i] are unique.","body":"var q = IntArray(numCourses+1) var edges = Array<MutableList<Int>>(numCourses+1) {mutableListOf<Int>()} var ind = IntArray(numCourses+1) var head = 0 var tail = 0 for (i in prerequisites) { ind[i[1]]++ edges[i[0]].add(i[1]) } var cnt = 0 for (i in 0 until numCourses) if (ind[i] == 0) { q[tail++] = i cnt++ } while (head < tail) { var top = q[head] for (i in edges[top]) { ind[i]-- if (ind[i] == 0) { cnt++ q[tail++] = i } } head++ } return cnt == numCourses } }","difficulty":"medium"}
{"id":1552,"signature":"class Solution { fun ok(position: IntArray, m: Int, mid: Int): Boolean {","docstring":"In universe Earth C-137, Rick discovered a special form of magnetic force between two balls if they are put in his new invented basket. Rick has `n` empty baskets, the `ith` basket is at `position[i]`, Morty has `m` balls and needs to distribute the balls into the baskets such that the minimum magnetic force between any two balls is maximum.\n\nRick stated that magnetic force between two different balls at positions `x` and `y` is `|x - y|`.\n\nGiven the integer array `position` and the integer `m`. Return the required force.\n\n\nExample 1:\nInput: position = [1,2,3,4,7], m = 3\nOutput: 3\nExplanation: Distributing the 3 balls into baskets 1, 4 and 7 will make the magnetic force between ball pairs [3, 3, 6]. The minimum magnetic force is 3. We cannot achieve a larger minimum magnetic force than 3.\n\n\nExample 2:\nInput: position = [5,4,3,2,1,1000000000], m = 2\nOutput: 999999999\nExplanation: We can use baskets 1 and 1000000000.\n\n\nConstraints:\n`n == position.length`\n`2 <= n <= 10^5`\n`1 <= position[i] <= 10^9`\nAll integers in `position` are distinct.\n\n`2 <= m <= position.length`","body":"var res = 1 val n = position.size var last = position[0] for (i in 1 until n) { if (position[i]- last >= mid) { res++ last = position[i] } } return res >= m } fun maxDistance(position: IntArray, m: Int): Int { val pos = position.sorted().toIntArray() var r = (pos[pos.size - 1] - pos[0]) \/ (m-1) var l = 1 var ans = 1 while (l <= r) { val mid = l+(r-l)\/2 if (ok(pos, m, mid)) { ans = mid l = mid+1 } else { r = mid-1 } } return ans } }","difficulty":"medium"}
{"id":329,"signature":"class Solution { fun longestIncreasingPath(matrix: Array<IntArray>): Int {","docstring":"Given an `m x n` integers `matrix`, return the length of the longest increasing path in `matrix`.\n\nFrom each cell, you can either move in four directions: left, right, up, or down. You may not move diagonally or move outside the boundary (i.e., wrap-around is not allowed).\n\n\nExample 1:\nInput: matrix = [[9,9,4],[6,6,8],[2,1,1]]\nOutput: 4\nExplanation: The longest increasing path is `[1, 2, 6, 9]`.\n\n\nExample 2:\nInput: matrix = [[3,4,5],[3,2,6],[2,2,1]]\nOutput: 4\nExplanation: The longest increasing path is `[3, 4, 5, 6]`. Moving diagonally is not allowed.\n\n\nExample 3:\nInput: matrix = [[1]]\nOutput: 1\n\nConstraints:\n`m == matrix.length`\n`n == matrix[i].length`\n`1 <= m, n <= 200`\n`0 <= matrix[i][j] <= 231 - 1`","body":"class Solution { private var dp = Array(1005){IntArray(1005)} private val dir = arrayOf(intArrayOf(0, -1), intArrayOf(0, 1), intArrayOf(-1, 0), intArrayOf(1, 0)) fun longestIncreasingPath(matrix: Array<IntArray>): Int { if (matrix.size == 0) return 0 var ans = 0 val n = matrix.size val m = matrix[0].size for (i in 0 until n) for (j in 0 until m) ans = Math.max(ans, dfs(matrix, i, j)) return ans } private fun dfs(matrix: Array<IntArray>, x: Int, y: Int): Int { if (dp[x][y] > 0) return dp[x][y] dp[x][y] = 1 for (i in 0 .. 3) { val nx = x+dir[i][0] val ny = y+dir[i][1] if (nx >= matrix.size || nx < 0 || ny >= matrix[0].size || ny < 0) continue if (matrix[nx][ny] > matrix[x][y]) { dp[x][y] = Math.max(dp[x][y], 1+dfs(matrix, nx, ny)) } } return dp[x][y] } }","difficulty":"hard"}
{"id":29,"signature":"class Solution { fun divide(dividend: Int, divisor: Int): Int {","docstring":"Given two integers `dividend` and `divisor`, divide two integers without using multiplication, division, and mod operator.\n\nReturn the quotient after dividing `dividend` by `divisor`.\n\nThe integer division should truncate toward zero, which means losing its fractional part. For example, `truncate(8.345) = 8` and `truncate(-2.7335) = -2`.\n\nNote: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: `[\u2212231, 231 \u2212 1]`. For this problem, assume that your function returns `231 \u2212 1` when the division result overflows.\n\n\nExample 1:\nInput: dividend = 10, divisor = 3\nOutput: 3\nExplanation: 10\/3 = truncate(3.33333..) = 3.\n\n\nExample 2:\nInput: dividend = 7, divisor = -3\nOutput: -2\nExplanation: 7\/-3 = truncate(-2.33333..) = -2.\n\n\nExample 3:\nInput: dividend = 0, divisor = 1\nOutput: 0\n\nExample 4:\nInput: dividend = 1, divisor = 1\nOutput: 1\n\nConstraints:\n`-231 <= dividend, divisor <= 231 - 1`\n`divisor != 0`","body":"if (dividend == Int.MIN_VALUE && divisor == -1) { return Int.MAX_VALUE } var a = Math.abs(dividend.toLong()) var b = Math.abs(divisor.toLong()) var res = 0 while (a >= b) { var sum = b var cnt = 1 while (sum+sum <= a) { sum += sum cnt += cnt } a -= sum res += cnt } if ((dividend < 0 && divisor > 0) || (dividend > 0 && divisor < 0)) res = -res return res } }","difficulty":"medium"}
