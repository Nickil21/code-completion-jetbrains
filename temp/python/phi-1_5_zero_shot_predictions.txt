if self.debug_level >= DEBUG_LEVEL: self.log
self.logger.info(message) self.logger.info(use
"if request.user == self.user: self.messages = response self.messages_count = len(self.messages) return True return False def get_messages(self, limit=None): """""" Get all messages for this user """""" if limit is None: "
if auth is None: auth = self.auth if eager: return self.get_table(name, auth=auth) else: return self.get_table(name, auth=auth, e
"def decorator(f): """""" View decorator that handles JSON based API requests and responses consistently. """""" @wraps(f) def wrapper(*args, **kwargs): """""" View decorator that handles JSON based API requests and responses consistently. """""" if not require_token: # If no token is provided, check if it is set in the request headers if 'Authorization' not in request.headers: # If no token is provided, check if it is set in the request headers if 'X-Auth-Token' not in request.headers: # If no token is provided, check if it is set in the request headers if 'X-Auth-Token' not in request.headers: # If no token is provided, check if it is set in the request headers if 'X-Auth-Token' not in request.headers: # If no token is provided, check if it is set in the request headers if 'X-Auth-Token' not in request.headers: # If no token is provided, check if it is set in the request headers if 'X-Auth-Token' not in request.headers: # If no token is provided, check if it is set in the request headers if 'X-Auth-Token' not in request.h"
"tweets = [] for page in pages: tweets.extend(self.get_tweets_from_page(user, page)) return tweets """""" Gets tweets for a given user, via the Twitter API. """""" tweets = [] for page in pages: tweets.extend(self.get_tweets_from_page(user, page)) return tweets """""" Gets tweets for a given user, via the Twitter API. """""" tweets = [] for page in pages: tweets.extend(self.get_tweets_from_page(user, page)) return tweets """""" Gets tweets for a given user, via the Twitter API. """""" tweets = [] for page in pages: tweets.extend(self.get_tweets_from_page(user, page)) return tweets """""" Gets tweets for a given user, via the Twitter API. """""" tweets = [] for page in pages: tweets.extend(self.get_tweets_from_page(user, page)) return tweets """""" Gets tweets for a given user, via the Twitter API. """""" tweets = [] for page in pages: tweets.extend(self.get_tweets_from_page(user, page)) return tweets """""" Gets tweets for a given user, via the Twitter API. """""" tweets = [] for page in pages: tweets.extend(self.get_tweets_from_page(user, page)) return tweets """""" Gets tweets for a given user, via the Twitter API. """""" tweets = [] for page in pages: tweets.extend(self.get_tweets_from_page(user, page)) return tweets """""" Gets tweets for a given user, via the Twitter API. """""" tweets = [] for page in pages: tweets.extend(self.get_tweets_from_page(user, page)) return tweets """""" Gets tweets for a given user, via the Twitter API. """""" tweets = [] for page in pages: tweets.extend(self.get_tweets_from_page(user, page)) return tweets """""" Gets tweets for a given user, via the Twitter API. """""" tweets = [] for page in pages: tweets.extend(self.get_tweets_from_page(user, page)) return tweets """""" Gets tweets for a given user, via the Twitter API. """""" tweets = [] for"
# Get the circularity circularity = np.mean(data, axis=0) # Get the deformation deformation = np.zeros_like(data) for i in range(data.shape[
return [node for node in self.nodes if not n
return self.tree.get(label) def get_children(self,
return [node.name for node in self.nodes i
return cls(name, length, descendants, **kw) @classmethod<EOL><INDENT>def create(cls, name=None, length=None, descendants=No
"return self._newick @property<EOL><INDENT>def name(self):<DEDENT> """""" The name of the Node. """""" return self._name @property<EOL><INDENT>def children(self):<DEDENT> """""" The children of the Node. """""" return self._chil"
"return [Tree.fromstring(s, strip_comments=strip_comments, **kw) for s in s.splitlines()] """""" """""" """
if predicate is None: predicate = lambda n: True for node in self.subtree(predicate
"if strict: return self.__str__() else: return self.__unicode__() # Get the tree's root node. root = self.get_root() # Get the tree's root node's label. label = root.get_label() # Get the tree's root node's children. children = root.get_children() # Create the tree's ASCII art string. ascii_art = """" # Add the tree's root node's label to the ASCII art string. ascii_art += label + ""\n"" # Add the tree's root node's children to the ASCII "
self
self
if self.closed: raise Connecti
if not self.is_connected: rais
self.logger.de
"if timeout is None: timeout = self.timeout return await self.wait_for_command(cmd, timeout=timeout) def wait_for_command(self, cmd, timeout=None): """""" Wait for a command to be received. Parameters "
self.camsocket = await self.camsocket_class.connect(self.host, self.port) self.camsocket.setblocking(False) self.camsocket.settimeout(self.timeout) self.ca
if isinstance(commands, bytes): commands = [commands] for command in commands: self
self.__stream.close() self.__stream = None self.__stream_closed = True self
"logger_name = function.__name__ logger_module = inspect.getmodule(function) logger_name = logger_module.__name__ logger_module.logger.info(f""{logger_name} called {function.__name__}"") return function return decorator @logger def my_function(): """
self.logger.info('Starting autofocus job') self.autofocus_job
self.sock.close() s
"if q == '""': return '""' elif q == ""'"": return ""'"" else: return q #return q #r"
return self.filter(**params) def filter
"if self.collection_name is None: # If the collection name is not set, # try to find the collection that the # ""href"" refers to. collection_name = result.get('href') if collection_name is None: # If the collection name is not set, # try to find the collection that the # ""href"" refers to. collection_name = self.collection_name if collection_name is None: # If the collection name is not set, # try to find the collection that the # ""href"" refers to. collection_name "
return self.query(**params) def _get_query_params(self, params
if create: section.create_variable(value) else: section.set_variable(value) return '\n'
if not quiet: print('Reading file:', map_files) if not edit: print('Reading file:', map_files) if not create: print('Reading file:', map_files) if not phusion: print('Reading file:', map_files) if not phusion_path: print('Reading file:', map_files) if not quiet: print('Reading file:', map_files) if not edit: print('Reading file:', map_files) if not create: print('Reading file:', map_files) if not phusion: print('Reading file:', map_files) if not phusion_path: print('Reading file:', map_files) if not quiet: print('Reading file:', map_files) if not edit: print('Reading file:', map_files) if not create: print('Reading file:', map_files) if not phusion: print('Reading file:'
"ctx.invoke(edit, create) if __name__ == '__main__': main()<|endoftext|>#!/usr/bin/env python3 # -*- coding: utf-8 -*- """""" Created on Wed Apr 3 11:41:57 2019 @author: josef-pktd """""" import numpy as np import matplotlib.pyplot as plt from scipy.spatial import distance from scipy.spatial.distance import cdist from scipy.spatial.distance import pdist from scipy.spatial.distance import "
# Create the config folder config_folder = os.path.join(config_dir, section) if not os.path.exists(config_folder): os.makedirs(config_folder) # Create the config file config_file = os.path.join(config_folder, 'config.s3conf') with open(config_file, 'w') as f: f.write(remote_file) # Create the s3 config file config_file = os.path.join(config_folder, '
"return ''' <link rel=""stylesheet"" type=""text/css"" href=""{0}""> '''.format( os.path.join( os.path.dirname(__file__), 'css', '{0}.css'.format(version) ) ) @register.simple_tag def djfrontend_twbs_theme_js(version=None): """""" Returns Twitter Bootstrap Theme JS f"
if version is None: version = self.version if version == '1.0': return self.djfrontend_jquery_1_0 elif version == '1.1': return self.djfrontend_jquery_1_1 elif version == '1.2': return self.djfrontend_jquery_1_2
"return '\n'.join(files) """""" return '\n'.join(files) """""" return '\n'.join(files) """""" return '\n'.join(files) """""" return '\n'.join(files) """""" return '\n'.join(files) """""" return '\n'.join(files) """""" return '\n'.join(files) """""" return '\n'.join(files) """""" return '\n'.join(files) """""" return '\n'.join(files) """""" return '\n'.join(files) """""" return '\n'.join(files) """""" return '\n'.join(files) """""" return '\n'.join(files) """""" return '\n'.join(files) """""" return '\n'.join(files) """""" return '\n'.join(files) """""" return '\n'.join(files) """""" return '\n'.join(files) """""" return '\n'.join(files) """""" return '\n'.join(files) """""" return '\n'.join(files) """""" return '\n'.join("
"return self.client.search( location=self.location, type=self.entity_type, q=kwargs.get('q', ''), start=kwargs.get('start', 0), count=kwargs.get('count', 10) ) def get_location_by_id(self, location_id): """""" :param location_"
url = 'https://www.zomato.com/restaurant/{}/details'.format(restaurant_id) r = requests.get(url) r.r
"return self.restaurant_types.getEstablishments(city_id, **kwargs) """""" :param city_id: id of the city for which collections are needed :param lat: latitude :param lon: longitude Get a li"
self.cells = [] for cell in self.cells: self.cells.append(cell) self.cells[0]['value'] = self.cells[0]['value'].replace('\n', '') self.cells[0]['value'] = self.cells[0]['value'].replace('\t', '') self.cells[0]['value'] = self.cells[0]['value'].replace('\r', '') self.cells[0]['value'] = self.cells[0]['value'].replace('\x0B', '') self.cells[0]['value'] = self.cells[0]['value'].replace('\x0C',
"return self.__event_fields def __get_event_values(self): """""" Get the event values (rows) from the cells received. """""" return self.__event_values def __get_event_data(self): """""" Get the event data (cells) from the cells received. """""" return self.__event_data def __get_event_data_columns(self): """""" Get the event data columns (columns) from the cells received. """""" return self.__event_data_co"
return True 
"return self.get_items(category, offset) def get_items(self, category=CATEGORY_EVENT, offset=REMO_DEFAULT_OFFSET): """""" Retrieve all items for category using pagination """""" return self.get_items(category, offset) def get_items(self, category=CATEGORY_EVENT, offset=REMO_DEFAULT_OFFSET): """""" Retrieve all items for category using pagination """""" return self.get_items(category, offset) def get_items(self, category=CATEGORY_EVENT, offset=REMO_DEFAULT_OFFSET): """""" Retrieve all items for category using pagination """""" return self.get_items(category, offset) def get_items(self, category=CATEGORY_EVENT, offset=REMO_DEFAULT_OFFSET): """""" Retrieve all items for category using pagination """""" r"
if item.type == 'image': # image if item.offset is None: # image without offset return item else: # image with
return True
"return self.fetch_items(category, **kwargs) def fetch_items(self, category, **kwargs): """""" Fetch items :param category: the category of items to fetch :param kwargs: backend arguments :returns: a generator of items """""" if category is None: category = self.default_category if category not in self.categories: raise ValueError('Category %s not found' % category) if category in self.categories[category]: return self.categories[category][category] if category in self.categories: return self.categories[category] if category in self.default_categories: return self.default_categories[category] raise ValueError('Category %s not found' % category) def get_category(self, name): """""" Get category :param name: the name of the category :returns: the category """""" return self.cate"
"return cls.parser @classmethod<DEDENT><INDENT>def teardown_cmd_parser(cls):<DEDENT> """""" Removes the ReMo argument parser. """""" cls.parser = None @classmethod<DEDENT><IND"
"return sorted(self.crate_list, key=lambda x: x.name) def get_crate_info(self, crate_name): """""" Get crate info """""" "
return True 
return self.response.text def fetch_json(self, url, payload=None): 
"params = { ""page"": page, ""per_page"": self.per_page, ""sort"": ""name"", ""sort_order"": ""desc"", ""sort_field"": ""name"", ""sort_dir"": ""desc"", ""sort_dir_field"": ""name"", ""sort_dir_order"": ""desc"", ""sort_dir_desc"": ""desc"", ""sort_dir_desc_field"": ""name"", ""sort_dir_desc_order"": ""desc"", ""sort_dir_desc_desc"": ""desc"", ""sort_dir_desc_desc_field"": ""name"", ""sort_dir_desc_desc_order"": ""desc"", ""sort_dir_desc_desc_desc"": ""desc"", ""sort_dir_desc_desc_desc_field"": ""name"", ""sort_dir_de"
self.client = Client(self.host, self.port, self.username, self.p
if item.is_summary: return'summary' else: return 'crate' @staticmet
"return cls.crates_arg_parser @classmethod<DEDENT><INDENT>def setup_crates_arg_parser(cls):<DEDENT> """""" Returns the Crates argument parser. """""" return cls.crates_arg_parser @classmethod<DEDENT><INDENT>def setup_crates_arg_parser_with_help("
if not category: category = CATEGORY_CRATES if not from_date: from_date = DEFAULT_DATETIME self.__fetch(category, from_date) def __fetch(self, category, from_date): 
"return self.summary() def get_summary(self): """""" Get Crates.io summary """""" return self.summary() d"
"return self.questions.filter(question_id=question_id).order_by('-updated') def get_question_answers_by_id(self, question_id): """""" Retrieve all answers for a question from older to newer (updated) """""" return self.questions.filter(question_id=question_id).order_by('-updated') def "
if offset is None: offset = 0 return self.questions[offset:] # TODO: This is a hack to get the latest questions # from the API. It should be replaced with a # more elegant solution. # For now, this is the only way to get the latest # questions. # This is a hack to get the latest questions # from the API. It should be replaced with a # more elegant soluti
self.client = Client(self.url, self.username, self.passwor
if filter_classified: return item.metadata.get('classification', 'UNKNOWN') else: return item.metadata.get('cl
"return self.session.post(self.base_url, data=data) def get_token_from_token_response(self, response): """""" Get a token response from a token response. :param response: A token response. :type response: requests.Response :rtype: dict """""" return response.json() def get_token_from_token_response_with_headers(self, response): """""" Get a token response from a token response with headers. :param response: A token response. :typ"
# Parse the query string parameters params = parse_qs(uri.query) # Get the authorization code auth_code = params.get('auth_code') if auth_code is None: raise ValueError('No authorization code found in query string.') return auth_code # Return the authorization code return auth_code # Raise an exception if the authorization code is not found raise ValueError('No authorization code found in query string.') # Return the authorization code return auth_code # Raise an exception if the authorization code is not found raise ValueError('
return self.response def _get_redirect_ur
"if not self.client_id: raise ValueError(""client_id is required"") if not self.client_secret: raise ValueError(""client_secret is required"") if not self.redirect_uri: raise ValueError(""redirect_uri is required"") if not self.code: raise ValueError(""code is required"") if not self.params: raise ValueError(""params is required"") if not self.token: raise ValueError(""token is required"") if not self.grant_type: raise ValueError(""grant_type is required"") if not self.client_id_: raise ValueError(""client_id_ is required"") if not self.client_secret_: raise ValueError(""client_secret_ is required"") if not self.client_id_: raise ValueError(""client_id_ is required"") if not self.client_secret_: raise ValueError(""client_secret_ is required"") if not self.redirect_uri_: raise ValueError(""redirect_uri_ is required"") if not self.code_: raise ValueError(""code_ is required"") if not self.grant_type_: raise ValueError(""grant_type_ is required"") if not self.client_id_: raise ValueError(""client_id_ is required"") if not self.client_secret_: raise ValueError(""client_secret_ is required"") if not self.client_id_: raise ValueError(""client_id_ is required"") if not self.client_secret_: raise ValueError(""client_"
return s
"self._logger.debug(""Internal exception: %s"", exc) self._lo"
"return self.provider.get_token(code, **params) def get_refresh_token(self, code, **params): """""" Get a refresh token from the provider token URI. :param code: Authorization code. :type code: str :return: Dict containing refresh token, refresh token expiration date, etc. :rtype: d"
return parse_qs(urlparse(url).query) def url_query_params_to_dict(u
self.config = Config() self.config.build_dir = os.path.join(self.config.build_dir, self.config.name) self.config.cleanup_dir = os.path.join(self.config.cleanup_dir, self.config.name) self.config.buil
self.parser = argparse.ArgumentParser( description='A si
with open(fname, 'r') as f: return json.load(f) else: return None
return self.events.remove(name
self.data = [ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [11, 12, 13, 14, 15, 16, 17, 18, 19, 20], [21, 22, 23, 24, 25, 26, 27, 28, 29, 30], [31, 32, 33, 34, 35, 36, 37, 38, 39, 40], [41,
self.a = np.array([1, 2, 3]) self.b = np.array([4, 5, 6]) self.c = np.array([7, 8, 9]) self.d = np.array([10, 11, 12]) self.e = np.array([13, 14, 15]) self.f = np.array([16, 17, 18]) self.g = np.array([19, 20, 21]) self.h = np.array([22, 23, 24]) self.i = np.array([25, 26, 27]) self.j = np.array([28, 29, 30]) self.k = np.array([31, 32, 33]) self.l = np.array([34, 35, 36]) self.m = np.array([37, 38, 39]) self.n = np
self.content = content
return self.request(method, url, headers, body) # TODO: Add a method to the request class # that returns 
"return self.args def getKwargs(self): """""" Get the keyword arguments as a list of strings """""" return self.kwargs def getDefault(self)"
if location in self.configuration: # Check for additions if location in self.configuration[location]: # Check for removals else: # Addition self.configuration[location].append(receiver) self.configuration[location].sort() self.configuration[location].append(receiver) self.configuration[location].sort() self.configuration[location].append(receiver) self.configuration[location].sort() self.configuration[location].append(receiver) self.configuration[location].sort() self.configuration[location].append(receiver) self.configuration[location].sort() self.configuration[location].append(receiver) self.configuration[location].sort() self.configuration[location].append(receiver) self.configuration[location].sort() self.configuration[locat
"def messages(location, receiver): """""" Construct a function that checks a directory for messages The function checks for new messages and calls the appropriate method on the receiver. Sent messages are deleted. :param loc: """""" def messages(location, receiver):"
return self.status_code == 200 def __repr__(self): return '<HTTPStatus {}>'.format(self.status_code) def __str__(se
self.bad = Tr
self.good = 
"return TimerService(opt['freq'], opt['config'], opt['messages']) def makeService(opt): """""" Make a service :params opt: dictionary-like object with 'freq', 'config' and'messages' :returns: twisted.application.internet.TimerService that at opt['freq'] checks for stale """""" return TimerService(opt['freq'], opt['config'], opt['messages']) def makeService(opt): """""" Make a service :para"
"restarter(checker(time.time())) """""" "
"return self.runProcess(args, timeout, grace, reactor) def runProcess(self, args, timeout, grace, reactor): """""" Run a process, return a deferred that fires when it is done :params args: Process arguments :params timeout: Time before terminating process :params grace: Time before killing process aft """""" if not self.isProcessAvailable(args): self.logger.error(""Process %s is not available"", args) return defer.fail(RuntimeError(""Process %s is not available"" % args)) # Create a process process = subprocess.Popen(args, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, cwd=self.cwd, shell=True) # Create"
pass
pass
"if myEnv is None: myEnv = {} myEnv.update(self.env) self.env = myEnv return self.env #return self.env.copy() def _test(self, case, myEnv=None): """
if master.isHeart: return if master.isHeart is None: master.isHeart = True master.heart = self.heart self.h
"if contents =='restart': self.restart() elif contents =='restart-all': self.restart_all() else: raise ValueError('Invalid restart message: %s' % contents) return def restart(self): """""" Restart the server """""" self.logger.info('Restarting server') self.server.start() self.server.wait_for_termination() def restart_all(self): """""" Restart all servers """""" self.logger.info('Restarting al"
"self.processes.remove(name) def get_processes(self): """""" Get a list of all running processes :returns: list of process names """""" return s"
"print(""\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
if not places.has_process(name): places.create_process(name, place=plac
"return TimerService(opt['freq'], opt['config'], opt['messages']) return makeService def makeService(opt): """""" Make a service :params opt: dictionary-like object with 'freq', 'config' and'messages' :returns: twisted.application.internet"
return restarter(checker(timer)) :param tim
"restarter = Restarter(opt) path = os.path.join(restarter.path, opt['name']) return restarter, path def __init__(self, opt): """""" Initialize the restarter :params opt: d"
return keccak256(data) def 
return AccessRequest(pid_value, users, confirmed) # TODO: Add a method to the AccessRequest class that returns the # access request as a JSON object. # This method should be called by the AccessManager class. # The AccessManager class should then use the AccessRequest # object to create the access re
