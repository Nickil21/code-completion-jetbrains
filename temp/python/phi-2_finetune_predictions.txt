pass # </debug> # -------------- # Code # --
pass # end of def success # # def error(user, 
"if request.get('user') == self.id: messages = MessagesApi.get_messages(request['message']) for message in messages: self.messages.append(message) return response """""" Check for messages for this user and, if it exis"
"pass def view(name, auth=None): """""" Returns a given view for the given user. """""" pass def execute(query, auth=None): """""" Executes"
"@wraps(func) def wrapper(*args, **kwargs): """""" View decorator that handles JSON based API requests and responses consistently. :param methods: A list of allowed methods :param require_token: Whether API token is checked automatically or not """""" request = Request(args[0], kwargs) if require_token: token = request.get_token() if not token: return Response({""error"": ""Missing API token""}) method = request.get_method() if not methods or method not in methods: return Response({""error"": ""Invalid method""}) data = request.get_data() if not data: return Response({""error"": ""Missing data""}) try: response = func(data, method, token) if isinstance(response, dict): response = Response(response) else: response = Response(response[0], response[1]) return response except Exception as e: return Response({""error"": str(e)}) finally: request.close() return response """""" View decorator that handles JSON based API requests and responses consistently. :param methods: A list of allowed methods :param require_token: Whether API token is c"
"# TODO: Implement this method. pass """""" Complete this method so that it returns a list of tweets for a given user, in chronological order. Each tweet should be a dictionary with the following keys: 'id' (`str`): The tweet's id. 'created_at' (`str`): The tweet's creation time in the format `YYYY-MM-DD HH:MM:SS`. 'text' (`str`): The tweet's text. 'user' (`str`): The tweet's user. 'in_reply_to_status_id' (`str`): The id of the status that this tweet is in reply to, if any. 'in_reply_to_user_id' (`str`): The id of the user that this tweet is in reply to, if any. 'like_count' (`int`): The number of likes this tweet has. 'retweet_count' (`int`): The number of retweets this tweet has. 'user_id' (`str`): The user who created this tweet. """""" [<TWEET>] """""" Complete this method so that it returns a list of tweets for a given user, in chronological order. Each tweet should be a dictionary with the following keys: 'id' (`str`): The tweet's id. 'created_at' (`str`): The tweet's creation time in the format `YYYY-MM-DD HH:MM:SS`. 'text' (`str`): The tweet's text. 'user' (`str`): The tweet's user. 'in_reply_to_status_id' (`str`): The id of the status that this tweet is in reply to, if any. 'in_reply_to_user_id' (`str`): The id of the user that this tweet is in reply to, if any. 'like_count' (`int`): The number of likes this tweet has. 'retweet_count' (`int`): The number of retweets this tweet has. 'user_id' (`str`): The user who created this tweet. """""" [<TWEET>] """""" Implement the get_tweets method from the Twitter class. """""" [<TWEET>] """""" Complete this method so that it returns a list of tweets for a given user, in chronological order. Each tweet should be a dictionary with the following keys: 'id' (`str`): The tweet's id. 'creat"
data[:, [0, 1]] = np.c_[data[:, 0] + data[:, 2], data[:, 1] + data[:, 3]] chn_names[0] = 'deformation' chn_names[1] = 'deformation' return d
"pass def get_root(self): """""" Get the root no"
"pass def get_nodes(self, label): """""" Gets all node"
"pass def get_descendant_names(self): """""" G"
"[EOL] @classmethod<EOL>def get(cls, name): """""" Get a `Node` object by its label. :param name: Node label. :return: `Node` o"
"@property<EOL><INDENT>returns(self)<DEDENT> """""" The representation of the Node in Python code format. """""" @property<EOL><INDENT>def leaves(self):<DEDENT> """""" The list of leaves of the Node. """""" @property<EOL><INDENT"
from nltk.tree import Tree from nltk.tokenize import WhitespaceTokenizer tokenizer = WhitespaceTok
if predicate is None: predicate = lambda x: True for child in self.children: if pre
if strict: tree_symbols = {'[': '[', ']': ']', '{': '{', '}': '}', '<': '<', '>': '>'} else: tree_symbols = {'[': ']', ']': '[', '{': '}', '}': '{', '<': '>', '>': '<'} def ascii_art_rec(node, depth): if node is None: return'' * depth + '|' s ='' * depth + tree_symbols[node.val] + '-' + ascii_art_rec(node.left, depth+2) + ascii_art_rec(node.right, depth+2) if show_internal and node.val!= '#': s +='' + node.val + '-' +'' * (depth+2) +
pass
pass
pass [buffer_size] = struct.un
pass async def write(self, buf
pass [self.wri
"async with self.lock: if value is None: await asyncio.wait_for(cmd in self.reader, timeout) else: await asyncio.wait_for(cmd + "":"" + value in self.reader, timeout) return True # return await self.r"
"pass async def disconnect(self): """""" Disconnect from LASAF through a CAM-socket. """""" pass async def send(self, data): """""" Send data to LASAF through a CAM-"
if isinstance(commands[0], bytes): s = io.BytesIO(commands[0]) else: s = io.StringI
pass # # Implement close method for stream. # # Code block for close method
"import logging logger.info(function.__name__) return function """""" Decorate passed in function and log message to console logger. """""" from sys import stderr logging.getLogger("""").info(function.__name__, file=stderr) return function """""" Decorate p"
"pass def autofocus_complete(self): """""" Complete the autofocus"
pass [INST] <<SYS>>
"return q[-1] if q[-1]!= '""' else give_another_quote(q[:-1]) # # When you pass"
pass # [filter] # Searches in ManageIQ 
"result_collection = self.get_collection(result['href']) if result_collection!= self: return self[result_collection] else: return result['entity'] """""" Complete this method so that it returns the entity in the correct collection. """""" pass """""" Example of a valid ""href"" value: ""/books/[book_id]/"" Example of an invalid ""href"" value: ""/books/[book_id]/[chapter_id]/"" """""" pass [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ "
"pass def get_document(self, id): """""" Get a document from the c"
"pass @main.command('<STR_LIT>')<EOL>@click.argument('<STR_LIT>', cls=SectionArgument)<EOL>@click.argument('<STR_LIT:value>',<EOL>required=False)<EOL>@click.option('<STR_LIT>',<EOL>'<STR_LIT:-f>',<EOL>is_flag=True,help='<STR_LIT>')<EOL>def get_variable(section, create): """""" Get value of a variable in an environm"
""""""" [S3CONF] [S3CONF] """""" @click.pass_context """""" [S3CONF] [S3CONF] """""" [S3CONF] [S3CONF] """""" [S3CONF] [S3CONF] """""" [S3CONF] [S3CONF] """""" [S3CONF] [S3CONF] """""" [S3CONF] [S3CONF] """""" [S3CONF] [S3CONF] """""" [S3CONF] [S3CONF] """""" [S3CONF] [S3CONF] """""" [S3CONF] [S3CONF] """""" [S3CONF] [S3CONF] """""" [S3CONF] [S3CONF] """""" [S3CONF] [S3CONF] """""" [S3CONF] [S3CONF] """""" [S3CONF] [S3CONF] """""" [S3CONF] [S3CONF] """""" [S3CONF] [S3CONF] """""" [S3CONF] [S3CONF] """""" [S3CONF] [S3CONF] """""" [S3CONF] [S3CONF] """""" [S3CONF] [S3CONF] """""" [S3CONF] [S3CONF] """""" [S3CONF] [S3CONF] """""" [S3CONF] [S3CONF] """""" [S3CONF] [S3CONF] """""" [S3CONF] [S3CONF] """""" [S3CONF] [S3CONF] """""" [S3CONF] [S3CONF] """""" [S3CONF] [S3C"
ctx.exit(0) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) 
"pass @main.command('[SECTION]')<EOL>@click.option('-s', '--section', help='SECTION', required=True)<EOL> def get(section): """""" Prints the contents of the.s3conf config file in the provided section. """""" pass @main.command('[SECTION] [LOCATION]')<EOL>@click.option('-s', '--section', help='SECTION', required=True) @click.option('-l', '--location', help="
"if version is None: version = '3' url = 'https://raw.githubusercontent.com/twitter/bootstrap/' + version + '/themes/' return '<link rel=""stylesheet"" href=""' + url + 'djfrontend_twbs_theme_css.css"" />' @register.simple_tag<EOL>def djfrontend_twbs_theme_js(ve"
from django.core.management.base import Command command = Command.get_command_instance(version) return command.get_template('djfrontend_jquery.tpl').render()+'\n</EOL>' @register.simple_tag<EOL>def djfrontend_ht
from django.template.loader import get_template from django.utils.html import escape import re TEMPLATE = get_template('djfrontend_twbs_js.tpl') S = TEMPLATE.render(version=version, files=files) S = re.sub(r'[\s]+', '', S) S = re.sub(r'[\n]+', '', S) S = re.sub(r'[\t]+', '', S) S = re.sub(r'[\[]+', '', S) S = re.sub(r'[\]]+', '', S) S = re.sub(r'[{]+', '', S) S = re.sub(r'[}]+', '', S) S = re.sub(r'[\.]+', '', S) S = re.sub(r'[\[\]]+', '', S) S = re.sub(r'[\]\.]+', '', S) S = re.sub(r'[\[\[]+', '', S) S = re.sub(r'[\]\]+', '', S) S = re.sub(r'[\{\}]+', '', S) S = re.sub(r'[\;]+', '', S) S = re.sub(r'[\[\]]+', '', S) S = re.sub(r'[\]\.]+', '', S) S = re.
pass # @TODO implement search method # [ ] return json object # [ ] explain return format # [ ] example # [ ] test # [ ] complete # [ ] <|endoftext|>
"pass [ { ""id"": 8, ""name"": ""KFC"", ""address"": ""1, S.S. No. 7, K.S.S. Rd., Koramangala, Bangalore - 560"
"return [{'id': establishment['id'], 'name': establishment['name']} for establishment in self.db[city_id]['restaurants']] def getHotels(self, city_id, **kwargs): """""" :param city_id: id o"
pass # [{'@type':' ', 'value':' '}] [{'@type':' ', 'value':' '}] [{'@type':' ', 'value':' '}] [{'@type':' ', 'value':' '}] [{'@type':' ', 'value':' '}] [{'@type':' ', 'value':' '}] [{'@type':' ', 'value':' '}] [{'@type':' ', 'value':' '}] [{'@type':' ', 'value':' '}] [{'@type':' ', 'value':' '}] [{'@type':' ', 'value':' '}] [{'@type':' ', 'value':' '}] [{'@type':' ', 'value':' '}] [{'@type'
"return self.cells[0][0].get_event_fields() def __get_event_rows(self): """""" Get the events rows (rows) from the cells received. """""" return self.cells[0][1].get_event_rows() def __get_event_columns(self): """""" Get the events columns (columns) from the cells received. """""" return self.cells[1][0].get_event_columns() def __get_event_data(self): """""" Get the events data from the cells received. """
</INDENT> @c
"response = self.session.get(self.BASE_URL + category + ""/items"", params={'offset': offset, 'limit': 100}) items = response.json()['items'] next_offset = response.json()['nextOffset'] if 'nextOffset' in response.json() else REMO_DEFAULT_OFFSET return items, next_offset def get_items_by_id(self, item_id, offset=REMO_DEFAULT_OFFSET): """""" Retrieve all items for category using pagination """""" response = self.session.get(self.BASE_URL + item_id + ""/items"", params={'offset': offset, 'limit': 100}) items = response.json()['items'] next_offset = response.json()['nextOffset'] if 'nextOffset' in response.json() else REMO_DEFAULT_OFFSET return items, next_offset def get_items_by_date(self,"
offset = item['offset'] if filter_classified: offset = offset[offset['classified']] item['metadata'] = {'offse
</INDENT> @
"pass def fetch_users(self, **kwargs): """""" Fetch users :param kwargs: backend arguments :returns: a generator of users """""" pass def fetch_posts(self, category, **kwargs): """""" Fetch posts :param category: the category of posts to fetch :param kwargs: backend arguments :returns: a generator of posts """""" pass def fetch_comments(self, post_id, **kwargs): """""" Fetch comments :param post_id: the id of the post to fetch comments for :param kwargs: backend arguments :returns: a generator of comments """""" pass def fetch_user_posts(self, user_id, **kwargs): """""" Fetch posts by a user :param user_id: the id of the user to fetch posts for :param kwargs: backend arguments :returns: a generator of posts """""" pass def fetch_user_comments(self, user_id, **kwargs): """""" Fetch comments b"
"return argparse.ArgumentParser(description='ReMo') @classmethod<EOL><INDENT>def add_cmd_args(cls, parser): """""" Adds ReMo command-line arguments to the parser. """""" parse"
"from_page = int(from_page) page_size = 20 total_pages = (self.data[from_page][""total""] + page_size - 1) // page_si"
</INDENT> @c
"return self.response.text def json(self, payload=None): """""" Return "
"url = f""https://api.crates.io/v1/items?page={page}&sort=created&order=desc"" response = requests.get(url) response.raise_for_status() items = response.json()[""items""] return items def __fetch_sales(self, path, page=<NUM_LIT:1>): """""" Return the sales from Crates.io API using pagination """""" url = f""https://api.crates.io/v1/sales?page={page}&sort=created&order=desc"" response = requests.get(url) response.raise_for_status() sales = response.json()[""sales""] return"
self.client = Client(from_archive) if from_archive: self.client.
"@staticmethod<EOL><INDENT>def metadata_summary(item):<DEDENT> """""" E"
"return argparse.ArgumentParser(description='Generate a Dockerfile from a Crates project.') @classmethod<EOL><INDENT>def add_args(cls, parser): """""" Adds arguments to the parser. :param parser: The parser to add arguments to. """""" parser.add"
"response = requests.get(f""https://api.crates.io/v1/packages?category={category}&from={from_date.isoformat()}"") data = response.json() return data """""" Fetch package d"
"return self.get_url(self.SUMMARY_URL) @staticmethod def get_url(url): """""" Get url content. :param "
pass # return [{'answer_text': answer_text, 'answer_start': answer_start, 'answer_end': answer_end} for answer_text, answer_start, answer_end in self.sess.run(self.answer_pool[question_id])] # return [{'answer_text': answer_text, 'answer_start': answer_start, 'answer_end': answe
"pass def get_answers(self, offset=None): """""" Retrieve answers from older to newer updated starting offset """""" pass def get_solutions(self, offset=None): """""" Retrieve solutions from older to newer updated starting offset """""" pass def get_user_answers(self, offset=None): """""" Retrieve answers from older to newer updated starting offset """""" pass def get_user"
if from_archive: self.client = Client.from_archive(self.co
offset = self.get_offset(item) if filter_classified: offset = offset[offset[:, 1]!= 2] return np.hstack((offse
"response = requests.post(self.url + ""/token"", data=data) response.raise_for_status() return response """""" Get a token response from JSON data. :param data: JSON data containing authorization information. :type data: dict """""" response = requests.post(self.url + ""/token"", json=data) response.raise_for_status() return response """""" Get a token response from XML data. :param data: XML data containing authorization information"
"p = ParseURL(uri) qs = p.query if not qs: return None params = [kv[0] for kv in [kv.split(""="") for kv in qs.split(""&"")]] if len(params)!= 1: return None return params[0] """""" [ ""code"" ] """""" return None """""" [ ""token"" ] """""" return params[0] """""" [ ""error"" ] """""" return params[1] """""" [ ] """""" return None """""" [ ""complete"" ] """""" return True """""" [ ] """""" return False """""" [ ""next"" ] """""" p = ParseURL(uri) qs = p.query if not qs: return None params = [kv[0] for kv in [kv.split(""="") for kv in qs.split(""&"")]] if len(params)!= 1: return None retu"
return self.request.response def _invalid
"return Response( [ SYS_RESPONSE[grant_type], SYS_RESPONSE[client_id], SYS_RESPONSE[client_secret], SYS_RESPONSE[redirect_uri], SYS_RESPONSE[code], SYS_RESPONSE[params] ] ) """""" [ ""access_token"", ""token_type"", ""expires_in"", ""iss"", ""aud"", ""scope"", ""subject"" ] """""" [SYS_RESPONSE[grant_type]] [SYS_RESPONSE[client_id]] [SYS_RESPONSE[client_secret]] [SYS_RESPONSE[redirect_uri]] [SYS_RESPONSE[code]] [SYS_RESPONSE[params]] """""" [EOL] def get_token_response(self,<EOL>grant_type,<EOL>client_id,<EOL>client_secret,<EOL>redirect_uri,<EOL>code,<EOL>**params): """""" Generate access token JSON response. :param grant_type: Desired grant type. Must be ""authorization_code"". :type grant_type: str """""" return Response( [ SYS_RESPONSE[grant_type], SYS_RESPONSE[client_id], SYS_RESPONSE[client_secret], SYS_RESPONSE[redirect_uri], SYS_RESPONSE[code], SYS_RESPONSE[params] ] ) """""" [ ""access_token"", ""token_type"", ""expires_in"", ""iss"", ""aud"", ""scope"", ""subject"" ] """""" [EOL] def get_token_response_json(self,<EOL>grant_type,<EOL>client_id,<EOL>client_secret,<EOL>redirect_uri,<EOL>code,<EOL>**params): """""" Generate access token JSON response. :param grant_type: Desired grant type. Must be ""authorization_code"". :ty"
@propert
"pass def _handle_complete(self, result): """""" Handle the co"
"from. import Provider provider = Provider.get_instance() return provider.get_token(code, **params) """""" [INSTANCE] class MyProvider(Provider): """""" [END INSTANCE] """""" pass [SYSOURCES] class MyProvider(Provider): """""" [END SYSOURCES] """""" pass [SYSOURCES] class MyProvider(Provider): "
import re match = re.search(r'\?[^\s]*', url) if match: return dict
"pass def tearDown(self): """""" Cleanup configuration and build/cleanup directories """""" pass pass pass pass pass pass pass pass pass pass pass pass pass pass pass pass pass pass pass pass pass pass pass"
self.parser = argparse.ArgumentParser(description='Gener
"with open(fname, 'r') as f: return json.load(f) """""" Load JSON from a string """""
return [self.get_event_data(EV
"pass def test(self): """""" Test the function """""" pass def tearDown(self): """""" Tear down the test """""" pass pass pass pass pass pass pass pass pass pass pass pass pass pass pass pas"
"pass def test(self): """""" Test the function """""" pass def tearDown(self): """""" Tear down the test """""" pass pass pass pass pass pass pass pass pass pass pass pass pass pass pass pass pass pass pass pass pass pass pass pass pass pass pass pass pass pass pass pass pass pass pass pass pass pass pass pass pass pass pass pass pass pass pass pass pass pass pass pass pass pass pass pass pass pass pass pass pass pass pass pass"
pass def getContent(se
"pass def response(self, status_code, headers, body): """""" Pretend to receive a response """""" pass def close"
"return [self.getString()] def getString(self): """""" Get the argument as a string. Example: `""hello world""` """""" return self.value def "
"import json from pathlib import Path from typing import Callable def add_file(location, receiver): """""" Add a process configuration file to the directory The file must be a JSON file with the following structure: [ { ""name"": """", ""path"": """" } ] """""" import json from pathlib import Path from typing import Callable with open(location, 'r') as f: data = json.load(f) for item in data: receiver(item['name'], item['path']) f.close() return def remove_file(location, receiver): """""" Remove a process configuration file from the directory The file must be a JSON file with the following structure: [ ""name"": """", ""path"": """" ] """""" import json from pathlib import Path from typing import Callable with open(location, 'r') as f: data = json.load(f) f"
"import os from. import messages def messages(location, receiver): """""" Construct a function that checks a directory for messages The function checks for new messages and calls the appropriate method on the receiver. Sent messages are """""" import os from. import"
pass # [Complete this method] # Write your code here. # <Complete this method> # [Complete this method] # # The `ch
[10] def mark
[100] def ma
"freq = opt['freq'] messages = opt['messages'] config = opt['config'] return TimerService(freq, makeService, config, messages) """""" @example from pyspark.mllib.linalg import DenseMatrix from pyspark.mllib.regression import LinearRegression import time class MakeService(Service): def get(request): time.sleep(request.getInt('freq')) return DenseMatrix(3, 3, [1, 2, 3, 4, 5, 6, 7, 8, 9"
pass [end] [start] import time while
"from twisted.internet import reactor from twisted.process import Process from twisted.python import failure p = Process(args) p.timeout = timeout p.grace = grace p.start() return failure.Failure(reactor.stop) """""" Complete process and return its return code """""" from twisted.internet import reactor from twisted.process import Process p = Process(args) p.timeout = timeout p.grace = grace p.start() reactor.wait(timeout) return p.returnCode """""" Complete process and return its return code or raise an exception if it times out """""" from twisted.internet import reactor from twisted.process import Process"
pass
pass
"pass def replaceSystem(case, mySys=None): """""" Replace system temporarily, restoring it at end of test :params mySys: a dict-like object """""" pass "
"pass def maybeAddSuit(master): """""" Add a suit to a service collection Add a suit to a service.IServiceColle"
"if contents['type'] =='restart': self.restart() elif contents['type'] =='restart-all': self.restart_all() else: raise Exception('Unknown message type:'+ contents['type']) return {'complete': True} """""" Respond to a restart-complete message :params contents: string, contents of message parsed as JSON, and assumed to have a 'type' key, with value either'restart' """""" if contents['type"
"pass def get_processes(self): """""" Get a list of all processes :return: list of strings, names of processes """""" pass def get_process(self,"
@mainlib.COMMANDS.register(name='<SYS_STA
"pass """""" Complete this method so that it prints out the """""" pass """""" [/"
"freq = opt['freq'] config = opt['config'] messages = opt['messages'] return TimerService(freq, makeService, config, messages) """""" @classmethod def makeService(opt): """""" Make a service :params opt: dictionary-like object with 'freq', 'c"
[time.sleep(x) for x in timer] [restarter(x
"restarter = Restarter(opt['messages']) path = opt['path'] return restarter, path """""" """""" pass return Restarter(opt['messages']), None """""" pass # Restarter(opt['message"
return keccak(data) def has
"return AccessRequest(pid_value, users, confirmed) @classmethod def create_access_requests(pid_value, users, confirmed): """""" Access Requests. """""" return [create_access_request(pid_value[i], users[i], confirmed[i]) for i in range(len(pid_value))] @classmethod def get_access_requests(pid_value): """""" Get"
