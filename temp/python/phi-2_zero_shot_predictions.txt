self.logger.debug(user, message) def log_inf
self.messages.append( Message(level=MessageLev
"if self.messages_api and self.messages_api.has_message(request.user): self.messages_api.process_message(request.user, response) else: logger.debug(""No message for user %s"", request.user) return response else: logge"
"if auth is None: auth = self.auth if not auth: raise Exception(""No auth provided"") if not self.auth.is_user_authorized(name): rai"
def decorator(func): @wraps(func) def wrapper(*args, **kwargs): if require_token: token = request.headers.get('Authorization') if not token: return jsonify({'message': 'Token is missing'}), 401 else: try: response = func(*args, **kwargs) except Exception as e: return jsonify({'message': str(e)}), 500 else: return response else: return func(*args, **kwargs) return wrapper return decorator return decorator else: return func else: return func else: return func else: return func else: return func else: return func else: return func else: return func <|endoftext|>
"tweets = [] for page in range(1, pages + 1): tweets += get_tweets_page(user, page) return tweets else: raise ValueError(""Invalid value for 'pages' parameter."") else: raise ValueError(""Invalid value for 'user' parameter."") else: raise ValueError(""Invalid value for 'user' parameter."") else: raise ValueError(""Invalid value for 'user' parameter."") else: raise ValueError(""Invalid value for 'user' parameter."") else: raise ValueError(""Invalid value for 'user' parameter."") else: raise ValueError(""Invalid value for 'user' parameter."") else: raise ValueError(""Invalid value for 'user' parameter."") else: raise ValueError(""Invalid value for 'user' parameter."") ``` Exercise 5: Write a Python function that takes a Twitter API key, access token, and user ID as input, and returns the user's profile information. ```python import tweepy def get_user_profile(api_key, api_secret_key, access_token, access_token_secret, user_id): """""" Gets the profile information for a given Twitter user. """""" auth = tweepy.OAuthHandler(api_key, api_secret_key) auth.set_access_token(access_token, access_token_secret) api = tweepy.API(auth) user = api.get_user(user_id) return user.name, user.description, user.location, user.followers_count, user.friends_count ``` <|endoftext|>"
# Get the circularity circularity = data[chn_names[0]] # Get the deformation deformation = data[chn_names[1]] # Compute the deformation defo
return [n for n in self.children if not n.ch
return self.get_node(label) # --------------------
return [self.name] def get_leaf_names_and_
) ) return self.__class__(self.__class__.__name__, self.__class__.__bases__, self.__dict__) def __init__(self, name, bases,
"return self.newick @property<EOL><INDENT>def newick_with_branch_lengths(self): """""" The representation of the Node in Newick format with branch lengths. """""" return self.newick_with_branch_lengths @property<EOL><INDEN"
return [Tree.fromstring(line, strip_comments=strip_comments, **kw) for line in s.splitlines()] def
return visitor(self, predicate, **kw) :param kw: Keyword arguments passed to the vi
"if self.is_leaf(): return self.label else: return ascii_art(self.left, strict, show_internal) + \ self.label + \ ascii_art(self.right, strict, show_internal) def __str__(self): """""" Return a string representation of the tree. :return: str """""" if self.is_leaf(): return str(self.label) else: return str(self.left) +'' + str(self.label) +'' + str(self.right) def __repr__(self): """""" Return a string representation of the tree. :return: str "
self
self
return self.socket.recv(buffer
# TODO: Implement raise NotImp
self.write_buf
"self.logger.debug(""Waiting for %s"", cmd) if value is not None: self.logger.debug(""Waiting for %s:%s"", cmd, value) else: self.logger.debug(""Waiting for %s"", cmd) start = time.time() while True: if s"
self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) self.sock.settimeout(self.timeout) self.sock.connect((self.host, self.port)) self.sock.setblo
if isinstance(commands, bytes): commands = [commands] for command in commands: self
"self.stream.close() self.stream = None def __enter__(self): """""" Enter conte"
@functools.wraps(function) def wrapper(*args, **kwargs): logger(function.__name__) return function(*args, **kwargs) return wrapper return decorator else: return function else: return function else: return function else: return function else: ret
self.autofocus_job = self.autofocus_job_class(self, self.auto
self.sock.close() s
"if q == '""': return '""' elif q == ""'"": return ""'"" else: return q"
return self.__find_by(self.__filter_by(
"if result.get(""href"") == self.collection: return result else: for collection in self.collections: if result.get(""href"").startswith(collection): return self.get_entity_from_href(collection, result) else: return None else: return None def get_entity_from_href(self, collection, result): """""" Returns entity in correct collection. If the ""href"" value in result doesn't match the current collection, try to find the collection that the ""href"" refers to. """""" if result.get"
return SearchResult(self, self.search(**params)) def search(se
if create: if section not in env_file: env_file[section] = {} env_file[section][value] = '' else: if section in env_file: if value in env_file[section]: env_file[section][value] = '' else: env_file[section][value] = '' else: env_file[section] = {} env_file[section][value] = '' return @main.command('<STR_LIT>')<
"if section == 'phusion': if phusion_path: phusion_path = os.path.abspath(phusion_path) if not os.path.exists(phusion_path): click.echo(""phusion path does not exist: %s"" % phusion_path) sys.exit(1) if phusion: if not os.path.exists(phusion_path): click.echo(""phusion path does not exist: %s"" % phusion_path) sys.exit(1) if not os.path.isdir(phusion_path): click.echo(""phusion path is not a directory: %s"" % phusion_path) sys.exit(1) if not quiet: click.echo(""phusion path: %s"" % phusion_path) if not edit: click.echo(""phusion path: %s"" % phusion_path) if not create: click.echo(""phusion path: %s"" % phusion_path) if section =='map_files': if not quiet: click.echo(""map_files: %s"" "
ctx.obj = {'edit': edit, 'create': create} ctx.obj['s3'] = S3(ctx.obj['edit'], ctx.obj['create']) ctx.obj['s3'].main() return 0 return main except Exception as e: click.echo(e) return 1 except Exception as e: click.echo(e) return 1 except Exception as e: click.echo(e) return 1 except Exception as e: click.echo(e) return 1 except Exception as e: click.echo(e) return 1 except Excepti
"pass elif section == 'auth': @main.command('<STR_LIT>')<EOL>@click.argument('<STR_LIT>')<EOL>@click.argument('<STR_LIT>')<EOL>def auth(section, remote_file): """""" Creates the.s3conf config folder and.s3conf/config config file with the provided section name and configuration file. It is a very basic config file. Manually edit it in order to add credent"
"if version is None: version = djfrontend_twbs_theme_version return djfrontend_twbs_theme_url(version) } } } } } } } } } } """""" return template.render(version=version) def djfrontend_twbs_theme_url(version): """""" Returns the URL of the Twitter Bootstrap Theme "
"if version is None: return djfrontend_jquery_minified else: return djfrontend_jquery_version(version) """""" Returns minified jQuery JavaScript file according to version number. Included in HTML5 Boilerplate. """""" i"
if version is None: version = djfrontend_twbs_js.version if files is None: files = djfrontend_twbs_js.files return djfrontend_twbs_js.get_js(version, files) } {% endfor %} {% endblock %} {% endblock %} {% endblock %} {% endblock %} {% endblock %} {% endblock %} {% endblock %} {% endblock %} {% endblock %} {% endblock %} {% endblock %} {% endblock %} {% endblock %} {% endblock %} {% endblock %} {% endblock %} {% endblock %} {% endblock %} {% endblock %} {% endblock %} {% endblock %} {% endblock %} {% endblock %} {% endblock %} {% endblock %} {% endblock %} {% endblock %} {% endblock %} {% endblock %} {% endblock %} {% endblock %} {% endblock %} {% endblo
"return self.__search(self.__get_url(entity_id, entity_type, q, start, count), **kwargs) except Exception as e: print(e) return None def search_by_name(self, q, start=0, count=10): """""" :param q: search keyword :param start:"
# get the restaurant details restaurant_details = self.zomato.getRestaurantDetails(restaurant_id) # 
pass # return [self.getEstablishment(e) for e in self.getEstablishments(city_id, lat, lon)] # return [self.getEstablishment(e) for e in self.getEstablishments(city_id, lat, lon, **kwarg
# Get the spreadsheet feed cells json cells = self.feed.get_cells() # Loop through each cell for cell in cells: # Get the cell json cell_json = cell.get_json() # Get the cell title cell_title = cell_json.get('title') # Get the cell value cell_value = cell_json.get('value') # Get the cell type cell_type = cell_json.get('type') # Get the cell data cell_data = cell_json.get('data') # Get the c
"return self.cells[0].get_event_fields() def __get_event_values(self): """""" Get the events values (rows) from the cells received. """""" return self.cells[0].get_event_values() def __get_event_values_as_list(self): """""" Get the events values (rows) from the cells received. """""" return self.cells[0].get_event_values_as_list() def __get_event_values_as_dict(self): """""" Get the events values (rows) "
return True 
"items = [] page = 1 while True: items_page = self.get_items_page(category=category, offset=offset, page=page) if not items_page: break items.extend(items_page) page += 1 return items def get_items_page(self, category=CATEGORY_EVENT, offset=REMO_DEFAULT_OFFSET, page=1): """""" Retrieve items for category using pagination """""" items = [] page_size = self.get_page_size(category=category, page=page) offset = offset * page_size if offset > self.get_total_items(category=category): offset = self.get_total_items(category=category) items = self.get_items(category=category, offset=offset) return items def get_total_items(self, category=CATEGORY_EVENT): """""" Retrieve total items for category "
item.metadata = self.metadata(item, filter_classified=filter_classified) return item def _get_item_by_offset(s
return True
"pass def fetch_items_by_id(self, item_id, **kwargs): """""" Fetch items by id :param item_id: the id of the item to fetch :param kwargs: backend arguments :returns: a generator of items """""" pass def fetch_items_by_name(self, name, **kwargs): """""" Fetch items by name :param name: the name of the item to fetch :param kwargs: backend arguments :returns: a generator of items """""" pass def fetch_items_by_category(self, category, **kwargs): """""" Fetch items by category :param category: the category of items to fetch :param kwargs: backend arguments :returns: a generator of items """""" pass def fetch_items_by_tags(self, tags, **kwargs): """""" Fetch items by tags :param tags: the tags of the item to fetch :param kwargs: backend arguments :returns: a generator of items """""" pass def "
"parser = argparse.ArgumentParser( prog=cls.__name__, description=cls.__doc__, formatter_class=argparse.RawDescriptionHelpFormatter, ) parser.add_argument( ""--version"", "
"return self.get_page(from_page, 'crates') def get_crate_by_id(self, id): """""" Get a crate by its id """""" return self"
return True 
return self.response.text def fetch_json(self, url, payload=None): 
"# fetch the items from the API items = self.api.get_items(path, page=page) # return the items return items def __fetch_items_by_id(self, id): """""" Return the items from Crates.io API using pagination """""" # fetch the items from the API items = self.api.get_items_by_id(id) # return the items return items def __fetch_items_by_name(self, name): """""" Return the items from Crates.io API using pagination """""" # fetch the items from the API items = self.api.get_items_"
if from_archive: self.client = Client.from_archive(self.archive_
if item.startswith('summary'): return'summary' elif item.startswith
"parser = super().setup_cmd_parser() parser.add_argument( ""--crate-name"", type=str, help=""The name of the crate to create."", ) parser.add_argument( ""--crate-version"", type=str, help=""The version of the crate to create."", ) parser.add_argum"
"self.packages = self.__fetch_packages(category, from_date) self.summary = self.__fetch_summary(category, from_date) self.__save_data() :return: None """""" self.__fetch"
"return self.summary def get_crate_id(self): """""" Get Crate.io ID """""" return self.id def get_crate_n"
"answers = [] for answer in self.answers: if answer.question_id == question_id: answers.append(answer) return answers def get_question_answers_by_id(self, question_id): """""" Retrieve all answers for a question from older to newer (updated) """""" answers = [] for answer in self.answe"
"if offset is None: offset = 0 questions = [] for i in range(offset, self.questions_count): questions.append(self.questions[i]) return questions else: raise Exception(""Invalid offset"") else: raise Exception(""Invalid type"") else: raise Exception(""Invalid type"") else: raise Exception(""Invalid type"") else: raise Exception(""Invalid type"") else: raise Exceptio"
if from_archive: self.client = Client.from_archive(self.ar
"if filter_classified: item = self.filter_classified(item) if item is None: return None return { ""offset"": item"
"token = data.get('token') if token: return self.session.get(self.url, headers=self.headers, params=self.params, data=data, verify=self.verify, timeout=self.timeout, proxies=self.proxies, stream=self.stream, auth=self.auth) else: raise ValueError('Token not found in POST data.') def get_token_from_header(self): """""" Get a token response from the Authorization header. :rtype: requests.Response """""" token = self.headers.get("
"# Get the authorization code from the query string authorization_code = uri.split(""?"")[1].split(""&"")[0] # Return the authorization code return authorization_code """""" # Get the authorization code from the query string authorization_code = self.get_authorization_code_from_uri(self.uri) # Return the authorization code return authorization_code def get_authorization_code_from_uri(self, uri): """""" Get authorization code response from a URI. This method will ignore the domain and path of the request, instead automatically parsing the qu"
"return self.request( method=""POST"", url=s"
"return self.http_client.post( self.token_url, json={ ""grant_type"": grant_type, ""client_id"": client_id, ""client_secret"": client_secret, ""redirect_uri"": redirect_uri, ""code"": code, **params } ) def get_token_by_code(self, code, **params): """""" Generate access token HTTP response. :param code: Access token code. :type code: str :param **params: Additional parameters. :type **params: dict :return: Access token HTTP response. :rtype: requests.Response """""" return self.http_client.post( self.token_url, json={ ""code"": code, **params } ) def get_token_by_refresh_token(self, refresh_token, **params): """""" Generate access token HTTP response. :param refresh_token: Refresh token. :type refresh_token: str :param **params: Additional parameters. :type **params: dict :return: Access token HTTP response. :rtype: requests.Response """""" return self.http_client.post( self.token_url, json={ ""refresh_token"": refresh_token, **params } ) def get_token_by_client_credentials(self, client_credentials, **params): """""" Generate access token HTTP response. :param client_credentials: Client credentials. :type client_credentials: str :param **params: Additional parameters. :type **params: dict :return: Acces"
return s
"self.logger.exception( ""Error while processing %s: %s"", se"
"return self.token_provider.get_token(code, **params) def get_token_from_refresh_token(self, refresh_token, **params): """""" Get an access token from the refresh token URI. :param refresh_token: Refresh token. :type refresh_token: str :return: Dict containing access token, refresh "
return dict(parse_qsl(urlparse(url).query)) def url_query_params_to
self.config = configparser.ConfigParser() self.config.read('config.ini') self.config['DEFAULT']['log_level'] = 'INFO' self.config['DEFAULT']['log_file'] = 'logs/' self.config['DEFAULT']['log_file_rot
"self.parser = argparse.ArgumentParser( description=""This"
"with open(fname) as f: return json.load(f) def jsonTo(fname, data): """""" Save J"
return self.events.get(name, N
self.test_data = [ (1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
"self.test_data = [ (1, 2, 3), (4, 5, 6), (7, 8, 9), ] def test_addition(self): """""" Test the addition function """""" for a, b, c in self.test_data: self.assertEqual(addition(a, b), c) if __name__ == '__main__': unittest.main() ``` In this example, we define a test case called `TestAddition` that inherits from `unittest.TestCase`. We define a test method called `test_addition` that tests the `addition` function with a "
self.content = content
"# Do something with the request pass except Exception as e: print(f""Error: {e}"") traceback.print_exc() fi"
"return self.args def getArgsAsString(self): """""" Get the arguments as a string """""" return self.args def getArgsAsList(self): """""" Get "
"if os.path.exists(location): if os.path.isfile(location): if not os.path.exists(receiver): os.makedirs(receiver) with open(location, 'r') as f: config = json.load(f) if config: self.receiver(config) else: os.remove(location) return else: raise Exception(""File is not a file"") else: raise Exception(""Directory does not exist"") else: raise Exception(""Directory does not exist"") else: raise Exception(""Invalid receiver"")"
"if not os.path.exists(loc): os.makedirs(loc) for f in os.listdir(loc): if f.endswith("".msg""): msg = open(os.path.join(loc, f), ""r"") msg_lines = msg.readlines() msg.close() for line in msg_lines: if line.startswith(""Sent:""): receiver.send(line[7:]) elif line.s"
if self.state == 'error': self.state ='success' self.status = 200 self.headers['Content-Type'] = 'text/plain' self.
self.markBad(
self.good = 
if opt['config'] is None: opt['config'] = {} if opt['messages'] is None: opt['messages'] = {} if opt['freq'] is None: opt['freq'] = 0 if opt['messages'] is None: opt['messages'] = {} if opt['config'] is None: opt['config'] = {} if opt['messages'] is None: opt['messages'] = {} if opt['config'] is None: opt['config'] = {} if opt['messages'] is None: opt['messages'] = {} if opt['con
# Run the checker checker() # Run th
"def runProcess(args, timeout, grace, reactor): """""" Run a process, return a deferred that fires when it is done :params args: Process arguments :params timeout: Time before terminating process :params grace: Time before killing process aft """""" def runProcess(args, timeout, grace, reactor): """""" Run a process, return a deferred that fires when it is done :params args: Process arguments :params timeout: Time before terminating process :params grace: Time before killing process aft """""" def runProcess(args, timeout, grace, reactor): """""" Run a process, return a deferred that fires when it is done :para"
pass
pass
if myEnv is None: myEnv = {} self.env = myEnv yield self.env = oldEnv return replaceEnvironment else: return replaceEnvironment def replaceEnviro
"if master.heart is None: master.heart = heart else: raise ValueError(""A service collector already has a hea"
if contents['type'] =='restart': self.restart() elif contents['type'] =='restart-all': self.restart_all() else: raise ValueError('Unknown restart message type: %s' % contents['type']) return True except ValueError as e: print(e) return False except KeyError as e: print(e) return False except TypeError as e: print(e) return False except Exception as e: print(e) return False return 
self.processes.pop(name) self.processes_by_name.pop(name) self.processes_by_id.pop(name) self.processes_by_pid.pop(name) self.processes_b
@mainlib.COMMANDS.register(name='<STR_LIT
if not places.is_process_running(name): places.start_process(name) else
"if opt['freq'] is None: return else: return TimerService(opt['freq'], makeService, opt['config'], opt['messages']) def makeService(self, opt): """""" Make a service :params opt: dictionary-like object with 'freq', 'config' and'messages' :"
""
restarter = opt.get('restarter', None) path = opt.get('path', None) if restarter is None: raise ValueError('Restarter is required') if path is None: raise ValueError('
"return keccak(data) """""" Ret"
"access_request = AccessRequest(pid_value, users, confirmed) return access_request except Exception as e: logging.error(f""Error while creating access request: {e}"") return None else: return None else: return None else: return None else: return None else: return None else: return None def get_access_re"
